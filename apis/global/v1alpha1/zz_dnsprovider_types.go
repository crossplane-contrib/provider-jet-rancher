/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AlidnsConfigObservation struct {
}

type AlidnsConfigParameters struct {

	// +kubebuilder:validation:Required
	AccessKey *string `json:"accessKey" tf:"access_key,omitempty"`

	// +kubebuilder:validation:Required
	SecretKey *string `json:"secretKey" tf:"secret_key,omitempty"`
}

type CloudflareConfigObservation struct {
}

type CloudflareConfigParameters struct {

	// +kubebuilder:validation:Required
	APIEmail *string `json:"apiEmail" tf:"api_email,omitempty"`

	// +kubebuilder:validation:Required
	APIKey *string `json:"apiKey" tf:"api_key,omitempty"`

	// +kubebuilder:validation:Optional
	ProxySetting *bool `json:"proxySetting,omitempty" tf:"proxy_setting,omitempty"`
}

type DNSProviderObservation struct {
	DNSProvider *string `json:"dnsProvider,omitempty" tf:"dns_provider,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type DNSProviderParameters struct {

	// +kubebuilder:validation:Optional
	AlidnsConfig []AlidnsConfigParameters `json:"alidnsConfig,omitempty" tf:"alidns_config,omitempty"`

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	CloudflareConfig []CloudflareConfigParameters `json:"cloudflareConfig,omitempty" tf:"cloudflare_config,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	RootDomain *string `json:"rootDomain" tf:"root_domain,omitempty"`

	// +kubebuilder:validation:Optional
	Route53Config []Route53ConfigParameters `json:"route53Config,omitempty" tf:"route53_config,omitempty"`
}

type Route53ConfigObservation struct {
}

type Route53ConfigParameters struct {

	// +kubebuilder:validation:Required
	AccessKey *string `json:"accessKey" tf:"access_key,omitempty"`

	// +kubebuilder:validation:Optional
	CredentialsPath *string `json:"credentialsPath,omitempty" tf:"credentials_path,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// +kubebuilder:validation:Required
	SecretKey *string `json:"secretKey" tf:"secret_key,omitempty"`

	// +kubebuilder:validation:Optional
	ZoneType *string `json:"zoneType,omitempty" tf:"zone_type,omitempty"`
}

// DNSProviderSpec defines the desired state of DNSProvider
type DNSProviderSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DNSProviderParameters `json:"forProvider"`
}

// DNSProviderStatus defines the observed state of DNSProvider.
type DNSProviderStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DNSProviderObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DNSProvider is the Schema for the DNSProviders API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type DNSProvider struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DNSProviderSpec   `json:"spec"`
	Status            DNSProviderStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DNSProviderList contains a list of DNSProviders
type DNSProviderList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DNSProvider `json:"items"`
}

// Repository type metadata.
var (
	DNSProvider_Kind             = "DNSProvider"
	DNSProvider_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DNSProvider_Kind}.String()
	DNSProvider_KindAPIVersion   = DNSProvider_Kind + "." + CRDGroupVersion.String()
	DNSProvider_GroupVersionKind = CRDGroupVersion.WithKind(DNSProvider_Kind)
)

func init() {
	SchemeBuilder.Register(&DNSProvider{}, &DNSProviderList{})
}
