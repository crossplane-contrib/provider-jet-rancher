/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type Amazonec2ConfigObservation struct {
}

type Amazonec2ConfigParameters struct {

	// AWS machine image
	// +kubebuilder:validation:Required
	AMI *string `json:"ami" tf:"ami,omitempty"`

	// AWS Access Key
	// +kubebuilder:validation:Optional
	AccessKeySecretRef *v1.SecretKeySelector `json:"accessKeySecretRef,omitempty" tf:"-"`

	// AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
	// +kubebuilder:validation:Optional
	BlockDurationMinutes *string `json:"blockDurationMinutes,omitempty" tf:"block_duration_minutes,omitempty"`

	// AWS root device name
	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// Encrypt EBS volume
	// +kubebuilder:validation:Optional
	EncryptEBSVolume *bool `json:"encryptEbsVolume,omitempty" tf:"encrypt_ebs_volume,omitempty"`

	// Optional endpoint URL (hostname only or fully qualified URI)
	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// Enables or disables the HTTP metadata endpoint on your instances
	// +kubebuilder:validation:Optional
	HTTPEndpoint *string `json:"httpEndpoint,omitempty" tf:"http_endpoint,omitempty"`

	// The state of token usage for your instance metadata requests
	// +kubebuilder:validation:Optional
	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens,omitempty"`

	// AWS IAM Instance Profile
	// +kubebuilder:validation:Optional
	IAMInstanceProfile *string `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// Disable SSL when sending requests
	// +kubebuilder:validation:Optional
	InsecureTransport *bool `json:"insecureTransport,omitempty" tf:"insecure_transport,omitempty"`

	// AWS instance type
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// Custom KMS key ID using the AWS Managed CMK
	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// AWS keypair to use; requires --amazonec2-ssh-keypath
	// +kubebuilder:validation:Optional
	KeypairName *string `json:"keypairName,omitempty" tf:"keypair_name,omitempty"`

	// Set this flag to enable CloudWatch monitoring
	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// Make the specified port number accessible from the Internet
	// +kubebuilder:validation:Optional
	OpenPort []*string `json:"openPort,omitempty" tf:"open_port,omitempty"`

	// Only use a private IP address
	// +kubebuilder:validation:Optional
	PrivateAddressOnly *bool `json:"privateAddressOnly,omitempty" tf:"private_address_only,omitempty"`

	// AWS Region
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// Set this flag to request spot instance
	// +kubebuilder:validation:Optional
	RequestSpotInstance *bool `json:"requestSpotInstance,omitempty" tf:"request_spot_instance,omitempty"`

	// Set retry count for recoverable failures (use -1 to disable)
	// +kubebuilder:validation:Optional
	Retries *string `json:"retries,omitempty" tf:"retries,omitempty"`

	// AWS root disk size (in GB)
	// +kubebuilder:validation:Optional
	RootSize *string `json:"rootSize,omitempty" tf:"root_size,omitempty"`

	// SSH Key file contents for sshKeyContents
	// +kubebuilder:validation:Optional
	SSHKeyContentsSecretRef *v1.SecretKeySelector `json:"sshKeyContentsSecretRef,omitempty" tf:"-"`

	// Set the name of the ssh user
	// +kubebuilder:validation:Optional
	SSHUser *string `json:"sshUser,omitempty" tf:"ssh_user,omitempty"`

	// AWS Secret Key
	// +kubebuilder:validation:Optional
	SecretKeySecretRef *v1.SecretKeySelector `json:"secretKeySecretRef,omitempty" tf:"-"`

	// AWS VPC security group
	// +kubebuilder:validation:Required
	SecurityGroup []*string `json:"securityGroup" tf:"security_group,omitempty"`

	// Skip adding default rules to security groups
	// +kubebuilder:validation:Optional
	SecurityGroupReadonly *bool `json:"securityGroupReadonly,omitempty" tf:"security_group_readonly,omitempty"`

	// AWS Session Token
	// +kubebuilder:validation:Optional
	SessionTokenSecretRef *v1.SecretKeySelector `json:"sessionTokenSecretRef,omitempty" tf:"-"`

	// AWS spot instance bid price (in dollar)
	// +kubebuilder:validation:Optional
	SpotPrice *string `json:"spotPrice,omitempty" tf:"spot_price,omitempty"`

	// AWS VPC subnet id
	// +kubebuilder:validation:Required
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`

	// AWS Tags (e.g. key1,value1,key2,value2)
	// +kubebuilder:validation:Optional
	Tags *string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Create an EBS optimized instance
	// +kubebuilder:validation:Optional
	UseEBSOptimizedInstance *bool `json:"useEbsOptimizedInstance,omitempty" tf:"use_ebs_optimized_instance,omitempty"`

	// Force the usage of private IP address
	// +kubebuilder:validation:Optional
	UsePrivateAddress *bool `json:"usePrivateAddress,omitempty" tf:"use_private_address,omitempty"`

	// Path to file with cloud-init user data
	// +kubebuilder:validation:Optional
	Userdata *string `json:"userdata,omitempty" tf:"userdata,omitempty"`

	// AWS VPC id
	// +kubebuilder:validation:Required
	VPCID *string `json:"vpcId" tf:"vpc_id,omitempty"`

	// Amazon EBS volume type
	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`

	// AWS zone for instance (i.e. a,b,c,d,e)
	// +kubebuilder:validation:Required
	Zone *string `json:"zone" tf:"zone,omitempty"`
}

type AzureConfigObservation struct {
}

type AzureConfigParameters struct {

	// Azure Availability Set to place the virtual machine into
	// +kubebuilder:validation:Optional
	AvailabilitySet *string `json:"availabilitySet,omitempty" tf:"availability_set,omitempty"`

	// Azure Service Principal Account ID (optional, browser auth is used if not specified)
	// +kubebuilder:validation:Optional
	ClientIDSecretRef *v1.SecretKeySelector `json:"clientIdSecretRef,omitempty" tf:"-"`

	// Azure Service Principal Account password (optional, browser auth is used if not specified)
	// +kubebuilder:validation:Optional
	ClientSecretSecretRef *v1.SecretKeySelector `json:"clientSecretSecretRef,omitempty" tf:"-"`

	// Path to file with custom-data
	// +kubebuilder:validation:Optional
	CustomData *string `json:"customData,omitempty" tf:"custom_data,omitempty"`

	// A unique DNS label for the public IP adddress
	// +kubebuilder:validation:Optional
	DNS *string `json:"dns,omitempty" tf:"dns,omitempty"`

	// Disk size if using managed disk
	// +kubebuilder:validation:Optional
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// Port number for Docker engine
	// +kubebuilder:validation:Optional
	DockerPort *string `json:"dockerPort,omitempty" tf:"docker_port,omitempty"`

	// Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
	// +kubebuilder:validation:Optional
	Environment *string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Fault domain count to use for availability set
	// +kubebuilder:validation:Optional
	FaultDomainCount *string `json:"faultDomainCount,omitempty" tf:"fault_domain_count,omitempty"`

	// Azure virtual machine OS image
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Azure region to create the virtual machine
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Configures VM and availability set for managed disks
	// +kubebuilder:validation:Optional
	ManagedDisks *bool `json:"managedDisks,omitempty" tf:"managed_disks,omitempty"`

	// Do not create a public IP address for the machine
	// +kubebuilder:validation:Optional
	NoPublicIP *bool `json:"noPublicIp,omitempty" tf:"no_public_ip,omitempty"`

	// Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
	// +kubebuilder:validation:Optional
	Nsg *string `json:"nsg,omitempty" tf:"nsg,omitempty"`

	// Make the specified port number accessible from the Internet
	// +kubebuilder:validation:Optional
	OpenPort []*string `json:"openPort,omitempty" tf:"open_port,omitempty"`

	// Specify a static private IP address for the machine
	// +kubebuilder:validation:Optional
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" tf:"private_ip_address,omitempty"`

	// Azure Resource Group name (will be created if missing)
	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// Username for SSH login
	// +kubebuilder:validation:Optional
	SSHUser *string `json:"sshUser,omitempty" tf:"ssh_user,omitempty"`

	// Size for Azure Virtual Machine
	// +kubebuilder:validation:Optional
	Size *string `json:"size,omitempty" tf:"size,omitempty"`

	// Assign a static public IP address to the machine
	// +kubebuilder:validation:Optional
	StaticPublicIP *bool `json:"staticPublicIp,omitempty" tf:"static_public_ip,omitempty"`

	// Type of Storage Account to host the OS Disk for the machine
	// +kubebuilder:validation:Optional
	StorageType *string `json:"storageType,omitempty" tf:"storage_type,omitempty"`

	// Azure Subnet Name to be used within the Virtual Network
	// +kubebuilder:validation:Optional
	Subnet *string `json:"subnet,omitempty" tf:"subnet,omitempty"`

	// Private CIDR block to be used for the new subnet, should comply RFC 1918
	// +kubebuilder:validation:Optional
	SubnetPrefix *string `json:"subnetPrefix,omitempty" tf:"subnet_prefix,omitempty"`

	// Azure Subscription ID
	// +kubebuilder:validation:Optional
	SubscriptionIDSecretRef *v1.SecretKeySelector `json:"subscriptionIdSecretRef,omitempty" tf:"-"`

	// Azure Tenant ID
	// +kubebuilder:validation:Optional
	TenantIDSecretRef *v1.SecretKeySelector `json:"tenantIdSecretRef,omitempty" tf:"-"`

	// Update domain count to use for availability set
	// +kubebuilder:validation:Optional
	UpdateDomainCount *string `json:"updateDomainCount,omitempty" tf:"update_domain_count,omitempty"`

	// Use private IP address of the machine to connect
	// +kubebuilder:validation:Optional
	UsePrivateIP *bool `json:"usePrivateIp,omitempty" tf:"use_private_ip,omitempty"`

	// Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
	// +kubebuilder:validation:Optional
	Vnet *string `json:"vnet,omitempty" tf:"vnet,omitempty"`
}

type DigitaloceanConfigObservation struct {
}

type DigitaloceanConfigParameters struct {

	// Digital Ocean access token
	// +kubebuilder:validation:Optional
	AccessTokenSecretRef *v1.SecretKeySelector `json:"accessTokenSecretRef,omitempty" tf:"-"`

	// Enable backups for droplet
	// +kubebuilder:validation:Optional
	Backups *bool `json:"backups,omitempty" tf:"backups,omitempty"`

	// Enable ipv6 for droplet
	// +kubebuilder:validation:Optional
	IPv6 *bool `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Digital Ocean Image
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Enable monitoring for droplet
	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// Enable private networking for droplet
	// +kubebuilder:validation:Optional
	PrivateNetworking *bool `json:"privateNetworking,omitempty" tf:"private_networking,omitempty"`

	// Digital Ocean region
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// SSH private key contents
	// +kubebuilder:validation:Optional
	SSHKeyContentsSecretRef *v1.SecretKeySelector `json:"sshKeyContentsSecretRef,omitempty" tf:"-"`

	// SSH key fingerprint
	// +kubebuilder:validation:Optional
	SSHKeyFingerprintSecretRef *v1.SecretKeySelector `json:"sshKeyFingerprintSecretRef,omitempty" tf:"-"`

	// SSH port
	// +kubebuilder:validation:Optional
	SSHPort *string `json:"sshPort,omitempty" tf:"ssh_port,omitempty"`

	// SSH username
	// +kubebuilder:validation:Optional
	SSHUser *string `json:"sshUser,omitempty" tf:"ssh_user,omitempty"`

	// Digital Ocean size
	// +kubebuilder:validation:Optional
	Size *string `json:"size,omitempty" tf:"size,omitempty"`

	// Comma-separated list of tags to apply to the Droplet
	// +kubebuilder:validation:Optional
	Tags *string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Path to file with cloud-init user-data
	// +kubebuilder:validation:Optional
	Userdata *string `json:"userdata,omitempty" tf:"userdata,omitempty"`
}

type HarvesterConfigObservation struct {
}

type HarvesterConfigParameters struct {

	// CPU count
	// +kubebuilder:validation:Optional
	CPUCount *string `json:"cpuCount,omitempty" tf:"cpu_count,omitempty"`

	// Disk bus
	// +kubebuilder:validation:Optional
	DiskBus *string `json:"diskBus,omitempty" tf:"disk_bus,omitempty"`

	// Disk size (in GiB)
	// +kubebuilder:validation:Optional
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// Image name
	// +kubebuilder:validation:Required
	ImageName *string `json:"imageName" tf:"image_name,omitempty"`

	// Memory size (in GiB)
	// +kubebuilder:validation:Optional
	MemorySize *string `json:"memorySize,omitempty" tf:"memory_size,omitempty"`

	// NetworkData content of cloud-init, base64 is supported
	// +kubebuilder:validation:Optional
	NetworkData *string `json:"networkData,omitempty" tf:"network_data,omitempty"`

	// Network model
	// +kubebuilder:validation:Optional
	NetworkModel *string `json:"networkModel,omitempty" tf:"network_model,omitempty"`

	// Network name
	// +kubebuilder:validation:Required
	NetworkName *string `json:"networkName" tf:"network_name,omitempty"`

	// SSH password
	// +kubebuilder:validation:Optional
	SSHPasswordSecretRef *v1.SecretKeySelector `json:"sshPasswordSecretRef,omitempty" tf:"-"`

	// SSH username
	// +kubebuilder:validation:Required
	SSHUser *string `json:"sshUser" tf:"ssh_user,omitempty"`

	// UserData content of cloud-init, base64 is supported
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// Virtual machine namespace
	// +kubebuilder:validation:Required
	VMNamespace *string `json:"vmNamespace" tf:"vm_namespace,omitempty"`
}

type LinodeConfigObservation struct {
}

type LinodeConfigParameters struct {

	// Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
	// +kubebuilder:validation:Optional
	AuthorizedUsers *string `json:"authorizedUsers,omitempty" tf:"authorized_users,omitempty"`

	// Create private IP for the instance
	// +kubebuilder:validation:Optional
	CreatePrivateIP *bool `json:"createPrivateIp,omitempty" tf:"create_private_ip,omitempty"`

	// Docker Port
	// +kubebuilder:validation:Optional
	DockerPort *string `json:"dockerPort,omitempty" tf:"docker_port,omitempty"`

	// Specifies the Linode Instance image which determines the OS distribution and base files
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// Linode Instance Label
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Specifies the region (location) of the Linode instance
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Root Password
	// +kubebuilder:validation:Optional
	RootPassSecretRef *v1.SecretKeySelector `json:"rootPassSecretRef,omitempty" tf:"-"`

	// Linode Instance SSH Port
	// +kubebuilder:validation:Optional
	SSHPort *string `json:"sshPort,omitempty" tf:"ssh_port,omitempty"`

	// Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
	// +kubebuilder:validation:Optional
	SSHUser *string `json:"sshUser,omitempty" tf:"ssh_user,omitempty"`

	// Specifies the Linode StackScript to use to create the instance
	// +kubebuilder:validation:Optional
	Stackscript *string `json:"stackscript,omitempty" tf:"stackscript,omitempty"`

	// A JSON string specifying data for the selected StackScript
	// +kubebuilder:validation:Optional
	StackscriptData *string `json:"stackscriptData,omitempty" tf:"stackscript_data,omitempty"`

	// Linode Instance Swap Size (MB)
	// +kubebuilder:validation:Optional
	SwapSize *string `json:"swapSize,omitempty" tf:"swap_size,omitempty"`

	// A comma separated list of tags to apply to the the Linode resource
	// +kubebuilder:validation:Optional
	Tags *string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Linode API Token
	// +kubebuilder:validation:Optional
	TokenSecretRef *v1.SecretKeySelector `json:"tokenSecretRef,omitempty" tf:"-"`

	// Prefix the User-Agent in Linode API calls with some 'product/version'
	// +kubebuilder:validation:Optional
	UaPrefix *string `json:"uaPrefix,omitempty" tf:"ua_prefix,omitempty"`
}

type MachineConfigObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`
}

type MachineConfigParameters struct {

	// +kubebuilder:validation:Optional
	Amazonec2Config []Amazonec2ConfigParameters `json:"amazonec2Config,omitempty" tf:"amazonec2_config,omitempty"`

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	AzureConfig []AzureConfigParameters `json:"azureConfig,omitempty" tf:"azure_config,omitempty"`

	// +kubebuilder:validation:Optional
	DigitaloceanConfig []DigitaloceanConfigParameters `json:"digitaloceanConfig,omitempty" tf:"digitalocean_config,omitempty"`

	// +kubebuilder:validation:Optional
	FleetNamespace *string `json:"fleetNamespace,omitempty" tf:"fleet_namespace,omitempty"`

	// Cluster V2 generate name. The pattern to generate machine config name. e.g  generate_name="prod-pool1" will generate "nc-prod-pool1-?????" names
	// +kubebuilder:validation:Required
	GenerateName *string `json:"generateName" tf:"generate_name,omitempty"`

	// +kubebuilder:validation:Optional
	HarvesterConfig []HarvesterConfigParameters `json:"harvesterConfig,omitempty" tf:"harvester_config,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	LinodeConfig []LinodeConfigParameters `json:"linodeConfig,omitempty" tf:"linode_config,omitempty"`

	// +kubebuilder:validation:Optional
	OpenstackConfig []OpenstackConfigParameters `json:"openstackConfig,omitempty" tf:"openstack_config,omitempty"`

	// +kubebuilder:validation:Optional
	VsphereConfig []VsphereConfigParameters `json:"vsphereConfig,omitempty" tf:"vsphere_config,omitempty"`
}

type OpenstackConfigObservation struct {
}

type OpenstackConfigParameters struct {

	// +kubebuilder:validation:Optional
	ActiveTimeout *string `json:"activeTimeout,omitempty" tf:"active_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationCredentialID *string `json:"applicationCredentialId,omitempty" tf:"application_credential_id,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationCredentialName *string `json:"applicationCredentialName,omitempty" tf:"application_credential_name,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationCredentialSecretSecretRef *v1.SecretKeySelector `json:"applicationCredentialSecretSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	AuthURL *string `json:"authUrl" tf:"auth_url,omitempty"`

	// +kubebuilder:validation:Required
	AvailabilityZone *string `json:"availabilityZone" tf:"availability_zone,omitempty"`

	// +kubebuilder:validation:Optional
	BootFromVolume *bool `json:"bootFromVolume,omitempty" tf:"boot_from_volume,omitempty"`

	// +kubebuilder:validation:Optional
	Cacert *string `json:"cacert,omitempty" tf:"cacert,omitempty"`

	// +kubebuilder:validation:Optional
	ConfigDrive *bool `json:"configDrive,omitempty" tf:"config_drive,omitempty"`

	// +kubebuilder:validation:Optional
	DomainID *string `json:"domainId,omitempty" tf:"domain_id,omitempty"`

	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Optional
	EndpointType *string `json:"endpointType,omitempty" tf:"endpoint_type,omitempty"`

	// +kubebuilder:validation:Optional
	FlavorID *string `json:"flavorId,omitempty" tf:"flavor_id,omitempty"`

	// +kubebuilder:validation:Optional
	FlavorName *string `json:"flavorName,omitempty" tf:"flavor_name,omitempty"`

	// +kubebuilder:validation:Optional
	FloatingIPPool *string `json:"floatingIpPool,omitempty" tf:"floating_ip_pool,omitempty"`

	// +kubebuilder:validation:Optional
	IPVersion *string `json:"ipVersion,omitempty" tf:"ip_version,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	ImageName *string `json:"imageName,omitempty" tf:"image_name,omitempty"`

	// +kubebuilder:validation:Optional
	Insecure *bool `json:"insecure,omitempty" tf:"insecure,omitempty"`

	// +kubebuilder:validation:Optional
	KeypairName *string `json:"keypairName,omitempty" tf:"keypair_name,omitempty"`

	// +kubebuilder:validation:Optional
	NetID *string `json:"netId,omitempty" tf:"net_id,omitempty"`

	// +kubebuilder:validation:Optional
	NetName *string `json:"netName,omitempty" tf:"net_name,omitempty"`

	// +kubebuilder:validation:Optional
	NovaNetwork *bool `json:"novaNetwork,omitempty" tf:"nova_network,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	PrivateKeyFileSecretRef *v1.SecretKeySelector `json:"privateKeyFileSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SSHPort *string `json:"sshPort,omitempty" tf:"ssh_port,omitempty"`

	// +kubebuilder:validation:Optional
	SSHUser *string `json:"sshUser,omitempty" tf:"ssh_user,omitempty"`

	// +kubebuilder:validation:Optional
	SecGroups *string `json:"secGroups,omitempty" tf:"sec_groups,omitempty"`

	// +kubebuilder:validation:Optional
	TenantDomainID *string `json:"tenantDomainId,omitempty" tf:"tenant_domain_id,omitempty"`

	// +kubebuilder:validation:Optional
	TenantDomainName *string `json:"tenantDomainName,omitempty" tf:"tenant_domain_name,omitempty"`

	// +kubebuilder:validation:Optional
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`

	// +kubebuilder:validation:Optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`

	// +kubebuilder:validation:Optional
	UserDataFile *string `json:"userDataFile,omitempty" tf:"user_data_file,omitempty"`

	// +kubebuilder:validation:Optional
	UserDomainID *string `json:"userDomainId,omitempty" tf:"user_domain_id,omitempty"`

	// +kubebuilder:validation:Optional
	UserDomainName *string `json:"userDomainName,omitempty" tf:"user_domain_name,omitempty"`

	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeDevicePath *string `json:"volumeDevicePath,omitempty" tf:"volume_device_path,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeID *string `json:"volumeId,omitempty" tf:"volume_id,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *string `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type VsphereConfigObservation struct {
}

type VsphereConfigParameters struct {

	// vSphere URL for boot2docker image
	// +kubebuilder:validation:Optional
	Boot2DockerURL *string `json:"boot2dockerUrl,omitempty" tf:"boot2docker_url,omitempty"`

	// vSphere CPU number for docker VM
	// +kubebuilder:validation:Optional
	CPUCount *string `json:"cpuCount,omitempty" tf:"cpu_count,omitempty"`

	// vSphere vm configuration parameters (used for guestinfo)
	// +kubebuilder:validation:Optional
	Cfgparam []*string `json:"cfgparam,omitempty" tf:"cfgparam,omitempty"`

	// If you choose creation type clone a name of what you want to clone is required
	// +kubebuilder:validation:Optional
	CloneFrom *string `json:"cloneFrom,omitempty" tf:"clone_from,omitempty"`

	// Filepath to a cloud-config yaml file to put into the ISO user-data
	// +kubebuilder:validation:Optional
	CloudConfig *string `json:"cloudConfig,omitempty" tf:"cloud_config,omitempty"`

	// vSphere cloud-init filepath or url to add to guestinfo
	// +kubebuilder:validation:Optional
	Cloudinit *string `json:"cloudinit,omitempty" tf:"cloudinit,omitempty"`

	// If you choose to clone from a content library template specify the name of the library
	// +kubebuilder:validation:Optional
	ContentLibrary *string `json:"contentLibrary,omitempty" tf:"content_library,omitempty"`

	// Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
	// +kubebuilder:validation:Optional
	CreationType *string `json:"creationType,omitempty" tf:"creation_type,omitempty"`

	// vSphere custom attributes, format key/value e.g. '200=my custom value'
	// +kubebuilder:validation:Optional
	CustomAttributes []*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// vSphere datacenter for virtual machine
	// +kubebuilder:validation:Optional
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	// vSphere datastore for virtual machine
	// +kubebuilder:validation:Optional
	Datastore *string `json:"datastore,omitempty" tf:"datastore,omitempty"`

	// vSphere datastore cluster for virtual machine
	// +kubebuilder:validation:Optional
	DatastoreCluster *string `json:"datastoreCluster,omitempty" tf:"datastore_cluster,omitempty"`

	// vSphere size of disk for docker VM (in MB)
	// +kubebuilder:validation:Optional
	DiskSize *string `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// vSphere folder for the docker VM. This folder must already exist in the datacenter
	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
	// +kubebuilder:validation:Optional
	Hostsystem *string `json:"hostsystem,omitempty" tf:"hostsystem,omitempty"`

	// vSphere size of memory for docker VM (in MB)
	// +kubebuilder:validation:Optional
	MemorySize *string `json:"memorySize,omitempty" tf:"memory_size,omitempty"`

	// vSphere network where the virtual machine will be attached
	// +kubebuilder:validation:Optional
	Network []*string `json:"network,omitempty" tf:"network,omitempty"`

	// vSphere password
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// vSphere resource pool for docker VM
	// +kubebuilder:validation:Optional
	Pool *string `json:"pool,omitempty" tf:"pool,omitempty"`

	// If using a non-B2D image you can specify the ssh password
	// +kubebuilder:validation:Optional
	SSHPasswordSecretRef *v1.SecretKeySelector `json:"sshPasswordSecretRef,omitempty" tf:"-"`

	// If using a non-B2D image you can specify the ssh port
	// +kubebuilder:validation:Optional
	SSHPort *string `json:"sshPort,omitempty" tf:"ssh_port,omitempty"`

	// If using a non-B2D image you can specify the ssh user
	// +kubebuilder:validation:Optional
	SSHUser *string `json:"sshUser,omitempty" tf:"ssh_user,omitempty"`

	// If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
	// +kubebuilder:validation:Optional
	SSHUserGroup *string `json:"sshUserGroup,omitempty" tf:"ssh_user_group,omitempty"`

	// vSphere tags id e.g. urn:xxx
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// vSphere username
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`

	// vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
	// +kubebuilder:validation:Optional
	VappIPAllocationPolicy *string `json:"vappIpAllocationPolicy,omitempty" tf:"vapp_ip_allocation_policy,omitempty"`

	// vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
	// +kubebuilder:validation:Optional
	VappIPProtocol *string `json:"vappIpProtocol,omitempty" tf:"vapp_ip_protocol,omitempty"`

	// vSphere vApp properties
	// +kubebuilder:validation:Optional
	VappProperty []*string `json:"vappProperty,omitempty" tf:"vapp_property,omitempty"`

	// vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
	// +kubebuilder:validation:Optional
	VappTransport *string `json:"vappTransport,omitempty" tf:"vapp_transport,omitempty"`

	// vSphere IP/hostname for vCenter
	// +kubebuilder:validation:Optional
	Vcenter *string `json:"vcenter,omitempty" tf:"vcenter,omitempty"`

	// vSphere Port for vCenter
	// +kubebuilder:validation:Optional
	VcenterPort *string `json:"vcenterPort,omitempty" tf:"vcenter_port,omitempty"`
}

// MachineConfigSpec defines the desired state of MachineConfig
type MachineConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MachineConfigParameters `json:"forProvider"`
}

// MachineConfigStatus defines the observed state of MachineConfig.
type MachineConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MachineConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MachineConfig is the Schema for the MachineConfigs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type MachineConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MachineConfigSpec   `json:"spec"`
	Status            MachineConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MachineConfigList contains a list of MachineConfigs
type MachineConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MachineConfig `json:"items"`
}

// Repository type metadata.
var (
	MachineConfig_Kind             = "MachineConfig"
	MachineConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MachineConfig_Kind}.String()
	MachineConfig_KindAPIVersion   = MachineConfig_Kind + "." + CRDGroupVersion.String()
	MachineConfig_GroupVersionKind = CRDGroupVersion.WithKind(MachineConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&MachineConfig{}, &MachineConfigList{})
}
