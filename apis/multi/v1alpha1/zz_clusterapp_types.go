/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AnswersObservation struct {
}

type AnswersParameters struct {

	// Cluster ID for answer
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Project ID for answer
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Key/values for answer
	// +kubebuilder:validation:Optional
	Values map[string]*string `json:"values,omitempty" tf:"values,omitempty"`
}

type ClusterAppObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	TemplateVersionID *string `json:"templateVersionId,omitempty" tf:"template_version_id,omitempty"`
}

type ClusterAppParameters struct {

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Multi cluster app answers
	// +kubebuilder:validation:Optional
	Answers []AnswersParameters `json:"answers,omitempty" tf:"answers,omitempty"`

	// Multi cluster app catalog name
	// +kubebuilder:validation:Required
	CatalogName *string `json:"catalogName" tf:"catalog_name,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Multi cluster app members
	// +kubebuilder:validation:Optional
	Members []MembersParameters `json:"members,omitempty" tf:"members,omitempty"`

	// Multi cluster app revision history limit
	// +kubebuilder:validation:Optional
	RevisionHistoryLimit *float64 `json:"revisionHistoryLimit,omitempty" tf:"revision_history_limit,omitempty"`

	// Multi cluster app revision name
	// +kubebuilder:validation:Optional
	RevisionID *string `json:"revisionId,omitempty" tf:"revision_id,omitempty"`

	// Multi cluster app roles
	// +kubebuilder:validation:Required
	Roles []*string `json:"roles" tf:"roles,omitempty"`

	// Multi cluster app targets
	// +kubebuilder:validation:Required
	Targets []TargetsParameters `json:"targets" tf:"targets,omitempty"`

	// Multi cluster app template name
	// +kubebuilder:validation:Required
	TemplateName *string `json:"templateName" tf:"template_name,omitempty"`

	// Multi cluster app template version
	// +kubebuilder:validation:Optional
	TemplateVersion *string `json:"templateVersion,omitempty" tf:"template_version,omitempty"`

	// Multi cluster app upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []UpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// Wait until multi cluster app is active
	// +kubebuilder:validation:Optional
	Wait *bool `json:"wait,omitempty" tf:"wait,omitempty"`
}

type MembersObservation struct {
}

type MembersParameters struct {

	// Member access type: member, owner, read-only
	// +kubebuilder:validation:Optional
	AccessType *string `json:"accessType,omitempty" tf:"access_type,omitempty"`

	// Member group principal id
	// +kubebuilder:validation:Optional
	GroupPrincipalID *string `json:"groupPrincipalId,omitempty" tf:"group_principal_id,omitempty"`

	// Member user principal id
	// +kubebuilder:validation:Optional
	UserPrincipalID *string `json:"userPrincipalId,omitempty" tf:"user_principal_id,omitempty"`
}

type RollingUpdateObservation struct {
}

type RollingUpdateParameters struct {

	// Rolling update batch size
	// +kubebuilder:validation:Optional
	BatchSize *float64 `json:"batchSize,omitempty" tf:"batch_size,omitempty"`

	// Rolling update interval
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`
}

type TargetsObservation struct {
	AppID *string `json:"appId,omitempty" tf:"app_id,omitempty"`

	HealthState *string `json:"healthState,omitempty" tf:"health_state,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type TargetsParameters struct {

	// Project ID for target
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`
}

type UpgradeStrategyObservation struct {
}

type UpgradeStrategyParameters struct {

	// Rolling update for upgrade strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []RollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`
}

// ClusterAppSpec defines the desired state of ClusterApp
type ClusterAppSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterAppParameters `json:"forProvider"`
}

// ClusterAppStatus defines the observed state of ClusterApp.
type ClusterAppStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterAppObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterApp is the Schema for the ClusterApps API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type ClusterApp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterAppSpec   `json:"spec"`
	Status            ClusterAppStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterAppList contains a list of ClusterApps
type ClusterAppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterApp `json:"items"`
}

// Repository type metadata.
var (
	ClusterApp_Kind             = "ClusterApp"
	ClusterApp_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterApp_Kind}.String()
	ClusterApp_KindAPIVersion   = ClusterApp_Kind + "." + CRDGroupVersion.String()
	ClusterApp_GroupVersionKind = CRDGroupVersion.WithKind(ClusterApp_Kind)
)

func init() {
	SchemeBuilder.Register(&ClusterApp{}, &ClusterAppList{})
}
