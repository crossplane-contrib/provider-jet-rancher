/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuditLogObservation struct {
}

type AuditLogParameters struct {

	// +kubebuilder:validation:Optional
	Configuration []ConfigurationParameters `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AuthenticationObservation struct {
}

type AuthenticationParameters struct {

	// +kubebuilder:validation:Optional
	Sans []*string `json:"sans,omitempty" tf:"sans,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type AuthorizationObservation struct {
}

type AuthorizationParameters struct {

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`
}

type AwsCloudProviderObservation struct {
}

type AwsCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Global []GlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceOverride []ServiceOverrideParameters `json:"serviceOverride,omitempty" tf:"service_override,omitempty"`
}

type AzureCloudProviderObservation struct {
}

type AzureCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AadClientCertPasswordSecretRef *v1.SecretKeySelector `json:"aadClientCertPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AadClientCertPath *string `json:"aadClientCertPath,omitempty" tf:"aad_client_cert_path,omitempty"`

	// +kubebuilder:validation:Required
	AadClientIDSecretRef v1.SecretKeySelector `json:"aadClientIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	AadClientSecretSecretRef v1.SecretKeySelector `json:"aadClientSecretSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Cloud *string `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoff *bool `json:"cloudProviderBackoff,omitempty" tf:"cloud_provider_backoff,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffDuration *float64 `json:"cloudProviderBackoffDuration,omitempty" tf:"cloud_provider_backoff_duration,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffExponent *float64 `json:"cloudProviderBackoffExponent,omitempty" tf:"cloud_provider_backoff_exponent,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffJitter *float64 `json:"cloudProviderBackoffJitter,omitempty" tf:"cloud_provider_backoff_jitter,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffRetries *float64 `json:"cloudProviderBackoffRetries,omitempty" tf:"cloud_provider_backoff_retries,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimit *bool `json:"cloudProviderRateLimit,omitempty" tf:"cloud_provider_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitBucket *float64 `json:"cloudProviderRateLimitBucket,omitempty" tf:"cloud_provider_rate_limit_bucket,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitQPS *float64 `json:"cloudProviderRateLimitQps,omitempty" tf:"cloud_provider_rate_limit_qps,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	MaximumLoadBalancerRuleCount *float64 `json:"maximumLoadBalancerRuleCount,omitempty" tf:"maximum_load_balancer_rule_count,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryAvailabilitySetName *string `json:"primaryAvailabilitySetName,omitempty" tf:"primary_availability_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryScaleSetName *string `json:"primaryScaleSetName,omitempty" tf:"primary_scale_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTableName *string `json:"routeTableName,omitempty" tf:"route_table_name,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupName *string `json:"securityGroupName,omitempty" tf:"security_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// +kubebuilder:validation:Required
	SubscriptionIDSecretRef v1.SecretKeySelector `json:"subscriptionIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	TenantIDSecretRef v1.SecretKeySelector `json:"tenantIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	UseInstanceMetadata *bool `json:"useInstanceMetadata,omitempty" tf:"use_instance_metadata,omitempty"`

	// +kubebuilder:validation:Optional
	UseManagedIdentityExtension *bool `json:"useManagedIdentityExtension,omitempty" tf:"use_managed_identity_extension,omitempty"`

	// +kubebuilder:validation:Optional
	VMType *string `json:"vmType,omitempty" tf:"vm_type,omitempty"`

	// +kubebuilder:validation:Optional
	VnetName *string `json:"vnetName,omitempty" tf:"vnet_name,omitempty"`

	// +kubebuilder:validation:Optional
	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty" tf:"vnet_resource_group,omitempty"`
}

type BackupConfigObservation struct {
}

type BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalHours *float64 `json:"intervalHours,omitempty" tf:"interval_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	S3BackupConfig []S3BackupConfigParameters `json:"s3BackupConfig,omitempty" tf:"s3_backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	SafeTimestamp *bool `json:"safeTimestamp,omitempty" tf:"safe_timestamp,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type BastionHostObservation struct {
}

type BastionHostParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	User *string `json:"user" tf:"user,omitempty"`
}

type BlockStorageObservation struct {
}

type BlockStorageParameters struct {

	// +kubebuilder:validation:Optional
	BsVersion *string `json:"bsVersion,omitempty" tf:"bs_version,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreVolumeAz *bool `json:"ignoreVolumeAz,omitempty" tf:"ignore_volume_az,omitempty"`

	// +kubebuilder:validation:Optional
	TrustDevicePath *bool `json:"trustDevicePath,omitempty" tf:"trust_device_path,omitempty"`
}

type CalicoNetworkProviderObservation struct {
}

type CalicoNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	CloudProvider *string `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`
}

type CanalNetworkProviderObservation struct {
}

type CanalNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type CisScanConfigObservation struct {
}

type CisScanConfigParameters struct {

	// Debug master
	// +kubebuilder:validation:Optional
	DebugMaster *bool `json:"debugMaster,omitempty" tf:"debug_master,omitempty"`

	// Debug worker
	// +kubebuilder:validation:Optional
	DebugWorker *bool `json:"debugWorker,omitempty" tf:"debug_worker,omitempty"`

	// Override Benchmark Version
	// +kubebuilder:validation:Optional
	OverrideBenchmarkVersion *string `json:"overrideBenchmarkVersion,omitempty" tf:"override_benchmark_version,omitempty"`

	// +kubebuilder:validation:Optional
	OverrideSkip []*string `json:"overrideSkip,omitempty" tf:"override_skip,omitempty"`

	// Profile
	// +kubebuilder:validation:Optional
	Profile *string `json:"profile,omitempty" tf:"profile,omitempty"`
}

type CloudProviderObservation struct {
}

type CloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AwsCloudProvider []AwsCloudProviderParameters `json:"awsCloudProvider,omitempty" tf:"aws_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	AzureCloudProvider []AzureCloudProviderParameters `json:"azureCloudProvider,omitempty" tf:"azure_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCloudProvider *string `json:"customCloudProvider,omitempty" tf:"custom_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OpenstackCloudProvider []OpenstackCloudProviderParameters `json:"openstackCloudProvider,omitempty" tf:"openstack_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	VsphereCloudProvider []VsphereCloudProviderParameters `json:"vsphereCloudProvider,omitempty" tf:"vsphere_cloud_provider,omitempty"`
}

type ClusterAuthEndpointObservation struct {
}

type ClusterAuthEndpointParameters struct {

	// +kubebuilder:validation:Optional
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type ClusterConfigObservation struct {
}

type ClusterConfigParameters struct {

	// Local cluster auth endpoint
	// +kubebuilder:validation:Optional
	ClusterAuthEndpoint []ClusterAuthEndpointParameters `json:"clusterAuthEndpoint,omitempty" tf:"cluster_auth_endpoint,omitempty"`

	// Default cluster role for project members
	// +kubebuilder:validation:Optional
	DefaultClusterRoleForProjectMembers *string `json:"defaultClusterRoleForProjectMembers,omitempty" tf:"default_cluster_role_for_project_members,omitempty"`

	// Default pod security policy template ID
	// +kubebuilder:validation:Optional
	DefaultPodSecurityPolicyTemplateID *string `json:"defaultPodSecurityPolicyTemplateId,omitempty" tf:"default_pod_security_policy_template_id,omitempty"`

	// Desired agent image
	// +kubebuilder:validation:Optional
	DesiredAgentImage *string `json:"desiredAgentImage,omitempty" tf:"desired_agent_image,omitempty"`

	// Desired auth image
	// +kubebuilder:validation:Optional
	DesiredAuthImage *string `json:"desiredAuthImage,omitempty" tf:"desired_auth_image,omitempty"`

	// Docker Root Dir
	// +kubebuilder:validation:Optional
	DockerRootDir *string `json:"dockerRootDir,omitempty" tf:"docker_root_dir,omitempty"`

	// Enable built-in cluster alerting
	// +kubebuilder:validation:Optional
	EnableClusterAlerting *bool `json:"enableClusterAlerting,omitempty" tf:"enable_cluster_alerting,omitempty"`

	// Enable built-in cluster monitoring
	// +kubebuilder:validation:Optional
	EnableClusterMonitoring *bool `json:"enableClusterMonitoring,omitempty" tf:"enable_cluster_monitoring,omitempty"`

	// Enable project network isolation
	// +kubebuilder:validation:Optional
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	// Rancher Kubernetes Engine Config
	// +kubebuilder:validation:Required
	RkeConfig []RkeConfigParameters `json:"rkeConfig" tf:"rke_config,omitempty"`

	// Cluster scheduled scan
	// +kubebuilder:validation:Optional
	ScheduledClusterScan []ScheduledClusterScanParameters `json:"scheduledClusterScan,omitempty" tf:"scheduled_cluster_scan,omitempty"`

	// Windows prefered cluster
	// +kubebuilder:validation:Optional
	WindowsPreferedCluster *bool `json:"windowsPreferedCluster,omitempty" tf:"windows_prefered_cluster,omitempty"`
}

type ConfigurationObservation struct {
}

type ConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBackup *float64 `json:"maxBackup,omitempty" tf:"max_backup,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type DNSObservation struct {
}

type DNSParameters struct {

	// Linear Autoscaler Params
	// +kubebuilder:validation:Optional
	LinearAutoscalerParams []LinearAutoscalerParamsParameters `json:"linearAutoscalerParams,omitempty" tf:"linear_autoscaler_params,omitempty"`

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Nodelocal dns
	// +kubebuilder:validation:Optional
	Nodelocal []NodelocalParameters `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	ReverseCidrs []*string `json:"reverseCidrs,omitempty" tf:"reverse_cidrs,omitempty"`

	// DNS service tolerations
	// +kubebuilder:validation:Optional
	Tolerations []TolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []UpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	UpstreamNameservers []*string `json:"upstreamNameservers,omitempty" tf:"upstream_nameservers,omitempty"`
}

type DiskObservation struct {
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	ScsiControllerType *string `json:"scsiControllerType,omitempty" tf:"scsi_controller_type,omitempty"`
}

type DrainInputObservation struct {
}

type DrainInputParameters struct {

	// +kubebuilder:validation:Optional
	DeleteLocalData *bool `json:"deleteLocalData,omitempty" tf:"delete_local_data,omitempty"`

	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type EcrCredentialPluginObservation struct {
}

type EcrCredentialPluginParameters struct {

	// +kubebuilder:validation:Optional
	AwsAccessKeyID *string `json:"awsAccessKeyId,omitempty" tf:"aws_access_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	AwsSecretAccessKeySecretRef *v1.SecretKeySelector `json:"awsSecretAccessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AwsSessionTokenSecretRef *v1.SecretKeySelector `json:"awsSessionTokenSecretRef,omitempty" tf:"-"`
}

type EtcdObservation struct {
}

type EtcdParameters struct {

	// +kubebuilder:validation:Optional
	BackupConfig []BackupConfigParameters `json:"backupConfig,omitempty" tf:"backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	CACert *string `json:"caCert,omitempty" tf:"ca_cert,omitempty"`

	// +kubebuilder:validation:Optional
	CertSecretRef *v1.SecretKeySelector `json:"certSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Creation *string `json:"creation,omitempty" tf:"creation,omitempty"`

	// +kubebuilder:validation:Optional
	ExternalUrls []*string `json:"externalUrls,omitempty" tf:"external_urls,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	GID *float64 `json:"gid,omitempty" tf:"gid,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	KeySecretRef *v1.SecretKeySelector `json:"keySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *string `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	Snapshot *bool `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	// +kubebuilder:validation:Optional
	UID *float64 `json:"uid,omitempty" tf:"uid,omitempty"`
}

type EventRateLimitObservation struct {
}

type EventRateLimitParameters struct {

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type FlannelNetworkProviderObservation struct {
}

type FlannelNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type GlobalObservation struct {
}

type GlobalParameters struct {

	// +kubebuilder:validation:Optional
	DisableSecurityGroupIngress *bool `json:"disableSecurityGroupIngress,omitempty" tf:"disable_security_group_ingress,omitempty"`

	// +kubebuilder:validation:Optional
	DisableStrictZoneCheck *bool `json:"disableStrictZoneCheck,omitempty" tf:"disable_strict_zone_check,omitempty"`

	// +kubebuilder:validation:Optional
	ELBSecurityGroup *string `json:"elbSecurityGroup,omitempty" tf:"elb_security_group,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesClusterID *string `json:"kubernetesClusterId,omitempty" tf:"kubernetes_cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesClusterTag *string `json:"kubernetesClusterTag,omitempty" tf:"kubernetes_cluster_tag,omitempty"`

	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`

	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type IngressObservation struct {
}

type IngressParameters struct {

	// +kubebuilder:validation:Optional
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultBackend *bool `json:"defaultBackend,omitempty" tf:"default_backend,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPPort *float64 `json:"httpPort,omitempty" tf:"http_port,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPSPort *float64 `json:"httpsPort,omitempty" tf:"https_port,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode,omitempty"`

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// Ingress add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []IngressTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update daemon set strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []IngressUpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type IngressTolerationsObservation struct {
}

type IngressTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IngressUpdateStrategyObservation struct {
}

type IngressUpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []UpdateStrategyRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type KubeAPIObservation struct {
}

type KubeAPIParameters struct {

	// +kubebuilder:validation:Optional
	AdmissionConfiguration map[string]*string `json:"admissionConfiguration,omitempty" tf:"admission_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysPullImages *bool `json:"alwaysPullImages,omitempty" tf:"always_pull_images,omitempty"`

	// +kubebuilder:validation:Optional
	AuditLog []AuditLogParameters `json:"auditLog,omitempty" tf:"audit_log,omitempty"`

	// +kubebuilder:validation:Optional
	EventRateLimit []EventRateLimitParameters `json:"eventRateLimit,omitempty" tf:"event_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecretsEncryptionConfig []SecretsEncryptionConfigParameters `json:"secretsEncryptionConfig,omitempty" tf:"secrets_encryption_config,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceNodePortRange *string `json:"serviceNodePortRange,omitempty" tf:"service_node_port_range,omitempty"`
}

type KubeControllerObservation struct {
}

type KubeControllerParameters struct {

	// +kubebuilder:validation:Optional
	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`
}

type KubeletObservation struct {
}

type KubeletParameters struct {

	// +kubebuilder:validation:Optional
	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	FailSwapOn *bool `json:"failSwapOn,omitempty" tf:"fail_swap_on,omitempty"`

	// +kubebuilder:validation:Optional
	GenerateServingCertificate *bool `json:"generateServingCertificate,omitempty" tf:"generate_serving_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	InfraContainerImage *string `json:"infraContainerImage,omitempty" tf:"infra_container_image,omitempty"`
}

type KubeproxyObservation struct {
}

type KubeproxyParameters struct {

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type LinearAutoscalerParamsObservation struct {
}

type LinearAutoscalerParamsParameters struct {

	// +kubebuilder:validation:Optional
	CoresPerReplica *float64 `json:"coresPerReplica,omitempty" tf:"cores_per_replica,omitempty"`

	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// +kubebuilder:validation:Optional
	NodesPerReplica *float64 `json:"nodesPerReplica,omitempty" tf:"nodes_per_replica,omitempty"`

	// +kubebuilder:validation:Optional
	PreventSinglePointFailure *bool `json:"preventSinglePointFailure,omitempty" tf:"prevent_single_point_failure,omitempty"`
}

type LoadBalancerObservation struct {
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	CreateMonitor *bool `json:"createMonitor,omitempty" tf:"create_monitor,omitempty"`

	// +kubebuilder:validation:Optional
	FloatingNetworkID *string `json:"floatingNetworkId,omitempty" tf:"floating_network_id,omitempty"`

	// +kubebuilder:validation:Optional
	LBMethod *string `json:"lbMethod,omitempty" tf:"lb_method,omitempty"`

	// +kubebuilder:validation:Optional
	LBProvider *string `json:"lbProvider,omitempty" tf:"lb_provider,omitempty"`

	// +kubebuilder:validation:Optional
	LBVersion *string `json:"lbVersion,omitempty" tf:"lb_version,omitempty"`

	// +kubebuilder:validation:Optional
	ManageSecurityGroups *bool `json:"manageSecurityGroups,omitempty" tf:"manage_security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorDelay *string `json:"monitorDelay,omitempty" tf:"monitor_delay,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorMaxRetries *float64 `json:"monitorMaxRetries,omitempty" tf:"monitor_max_retries,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorTimeout *string `json:"monitorTimeout,omitempty" tf:"monitor_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	UseOctavia *bool `json:"useOctavia,omitempty" tf:"use_octavia,omitempty"`
}

type MembersObservation struct {
}

type MembersParameters struct {

	// Member access type: member, owner, read-only
	// +kubebuilder:validation:Optional
	AccessType *string `json:"accessType,omitempty" tf:"access_type,omitempty"`

	// Member group principal id
	// +kubebuilder:validation:Optional
	GroupPrincipalID *string `json:"groupPrincipalId,omitempty" tf:"group_principal_id,omitempty"`

	// Member user principal id
	// +kubebuilder:validation:Optional
	UserPrincipalID *string `json:"userPrincipalId,omitempty" tf:"user_principal_id,omitempty"`
}

type MetadataObservation struct {
}

type MetadataParameters struct {

	// +kubebuilder:validation:Optional
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SearchOrder *string `json:"searchOrder,omitempty" tf:"search_order,omitempty"`
}

type MonitoringObservation struct {
}

type MonitoringParameters struct {

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Monitoring add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []MonitoringTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []MonitoringUpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type MonitoringTolerationsObservation struct {
}

type MonitoringTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MonitoringUpdateStrategyObservation struct {
}

type MonitoringUpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []MonitoringUpdateStrategyRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type MonitoringUpdateStrategyRollingUpdateObservation struct {
}

type MonitoringUpdateStrategyRollingUpdateParameters struct {

	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type NetworkObservation struct {
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	PublicNetwork *string `json:"publicNetwork,omitempty" tf:"public_network,omitempty"`
}

type NetworkTolerationsObservation struct {
}

type NetworkTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type NodelocalObservation struct {
}

type NodelocalParameters struct {

	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Node selector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`
}

type OpenstackCloudProviderGlobalObservation struct {
}

type OpenstackCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Required
	AuthURL *string `json:"authUrl" tf:"auth_url,omitempty"`

	// +kubebuilder:validation:Optional
	CAFile *string `json:"caFile,omitempty" tf:"ca_file,omitempty"`

	// +kubebuilder:validation:Optional
	DomainIDSecretRef *v1.SecretKeySelector `json:"domainIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	TenantIDSecretRef *v1.SecretKeySelector `json:"tenantIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`

	// +kubebuilder:validation:Optional
	TrustIDSecretRef *v1.SecretKeySelector `json:"trustIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	UsernameSecretRef v1.SecretKeySelector `json:"usernameSecretRef" tf:"-"`
}

type OpenstackCloudProviderObservation struct {
}

type OpenstackCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	BlockStorage []BlockStorageParameters `json:"blockStorage,omitempty" tf:"block_storage,omitempty"`

	// +kubebuilder:validation:Required
	Global []OpenstackCloudProviderGlobalParameters `json:"global" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Route []RouteParameters `json:"route,omitempty" tf:"route,omitempty"`
}

type PrivateRegistriesObservation struct {
}

type PrivateRegistriesParameters struct {

	// ECR credential plugin config
	// +kubebuilder:validation:Optional
	EcrCredentialPlugin []EcrCredentialPluginParameters `json:"ecrCredentialPlugin,omitempty" tf:"ecr_credential_plugin,omitempty"`

	// +kubebuilder:validation:Optional
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type QuestionsObservation struct {
}

type QuestionsParameters struct {

	// Default variable value
	// +kubebuilder:validation:Required
	Default *string `json:"default" tf:"default,omitempty"`

	// Required variable
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Variable type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Variable name
	// +kubebuilder:validation:Required
	Variable *string `json:"variable" tf:"variable,omitempty"`
}

type RkeConfigNetworkObservation struct {
}

type RkeConfigNetworkParameters struct {

	// +kubebuilder:validation:Optional
	CalicoNetworkProvider []CalicoNetworkProviderParameters `json:"calicoNetworkProvider,omitempty" tf:"calico_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CanalNetworkProvider []CanalNetworkProviderParameters `json:"canalNetworkProvider,omitempty" tf:"canal_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	FlannelNetworkProvider []FlannelNetworkProviderParameters `json:"flannelNetworkProvider,omitempty" tf:"flannel_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Plugin *string `json:"plugin,omitempty" tf:"plugin,omitempty"`

	// Network add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []NetworkTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// +kubebuilder:validation:Optional
	WeaveNetworkProvider []WeaveNetworkProviderParameters `json:"weaveNetworkProvider,omitempty" tf:"weave_network_provider,omitempty"`
}

type RkeConfigNodesObservation struct {
}

type RkeConfigNodesParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	DockerSocket *string `json:"dockerSocket,omitempty" tf:"docker_socket,omitempty"`

	// +kubebuilder:validation:Optional
	HostnameOverride *string `json:"hostnameOverride,omitempty" tf:"hostname_override,omitempty"`

	// +kubebuilder:validation:Optional
	InternalAddress *string `json:"internalAddress,omitempty" tf:"internal_address,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	NodeID *string `json:"nodeId,omitempty" tf:"node_id,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Role []*string `json:"role" tf:"role,omitempty"`

	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type RkeConfigObservation struct {
}

type RkeConfigParameters struct {

	// Optional duration in seconds of addon job.
	// +kubebuilder:validation:Optional
	AddonJobTimeout *float64 `json:"addonJobTimeout,omitempty" tf:"addon_job_timeout,omitempty"`

	// Optional addons descripton to deploy on rke cluster.
	// +kubebuilder:validation:Optional
	Addons *string `json:"addons,omitempty" tf:"addons,omitempty"`

	// Optional addons yaml manisfest to deploy on rke cluster.
	// +kubebuilder:validation:Optional
	AddonsInclude []*string `json:"addonsInclude,omitempty" tf:"addons_include,omitempty"`

	// Kubernetes cluster authentication
	// +kubebuilder:validation:Optional
	Authentication []AuthenticationParameters `json:"authentication,omitempty" tf:"authentication,omitempty"`

	// Kubernetes cluster authorization
	// +kubebuilder:validation:Optional
	Authorization []AuthorizationParameters `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// RKE bastion host
	// +kubebuilder:validation:Optional
	BastionHost []BastionHostParameters `json:"bastionHost,omitempty" tf:"bastion_host,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProvider []CloudProviderParameters `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns,omitempty"`

	// Enable/disable using cri-dockerd
	// +kubebuilder:validation:Optional
	EnableCriDockerd *bool `json:"enableCriDockerd,omitempty" tf:"enable_cri_dockerd,omitempty"`

	// Optional ignore docker version on nodes
	// +kubebuilder:validation:Optional
	IgnoreDockerVersion *bool `json:"ignoreDockerVersion,omitempty" tf:"ignore_docker_version,omitempty"`

	// Kubernetes ingress configuration
	// +kubebuilder:validation:Optional
	Ingress []IngressParameters `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// Optional kubernetes version to deploy
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Kubernetes cluster monitoring
	// +kubebuilder:validation:Optional
	Monitoring []MonitoringParameters `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// Kubernetes cluster networking
	// +kubebuilder:validation:Optional
	Network []RkeConfigNetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// Optional RKE cluster nodes
	// +kubebuilder:validation:Optional
	Nodes []RkeConfigNodesParameters `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// Optional prefix to customize kubernetes path
	// +kubebuilder:validation:Optional
	PrefixPath *string `json:"prefixPath,omitempty" tf:"prefix_path,omitempty"`

	// Optional private registries for docker images
	// +kubebuilder:validation:Optional
	PrivateRegistries []PrivateRegistriesParameters `json:"privateRegistries,omitempty" tf:"private_registries,omitempty"`

	// Optional use ssh agent auth
	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// Optional cluster level SSH certificate path
	// +kubebuilder:validation:Optional
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// Optional cluster level SSH private key path
	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// Kubernetes cluster services
	// +kubebuilder:validation:Optional
	Services []ServicesParameters `json:"services,omitempty" tf:"services,omitempty"`

	// RKE upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []UpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// Optional prefix to customize kubernetes path for windows
	// +kubebuilder:validation:Optional
	WinPrefixPath *string `json:"winPrefixPath,omitempty" tf:"win_prefix_path,omitempty"`
}

type RollingUpdateObservation struct {
}

type RollingUpdateParameters struct {

	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type RouteObservation struct {
}

type RouteParameters struct {

	// +kubebuilder:validation:Optional
	RouterID *string `json:"routerId,omitempty" tf:"router_id,omitempty"`
}

type S3BackupConfigObservation struct {
}

type S3BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessKeySecretRef *v1.SecretKeySelector `json:"accessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	BucketName *string `json:"bucketName" tf:"bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCA *string `json:"customCa,omitempty" tf:"custom_ca,omitempty"`

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SecretKeySecretRef *v1.SecretKeySelector `json:"secretKeySecretRef,omitempty" tf:"-"`
}

type ScanConfigObservation struct {
}

type ScanConfigParameters struct {

	// The cluster cis scan config
	// +kubebuilder:validation:Optional
	CisScanConfig []CisScanConfigParameters `json:"cisScanConfig,omitempty" tf:"cis_scan_config,omitempty"`
}

type ScheduleConfigObservation struct {
}

type ScheduleConfigParameters struct {

	// Crontab schedule
	// +kubebuilder:validation:Required
	CronSchedule *string `json:"cronSchedule" tf:"cron_schedule,omitempty"`

	// Cluster scan retention
	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`
}

type ScheduledClusterScanObservation struct {
}

type ScheduledClusterScanParameters struct {

	// Enable scheduled cluster scan
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Cluster scan config
	// +kubebuilder:validation:Required
	ScanConfig []ScanConfigParameters `json:"scanConfig" tf:"scan_config,omitempty"`

	// Schedule cluster scan config
	// +kubebuilder:validation:Required
	ScheduleConfig []ScheduleConfigParameters `json:"scheduleConfig" tf:"schedule_config,omitempty"`
}

type SchedulerObservation struct {
}

type SchedulerParameters struct {

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type SecretsEncryptionConfigObservation struct {
}

type SecretsEncryptionConfigParameters struct {

	// +kubebuilder:validation:Optional
	CustomConfig *string `json:"customConfig,omitempty" tf:"custom_config,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServiceOverrideObservation struct {
}

type ServiceOverrideParameters struct {

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// +kubebuilder:validation:Optional
	SigningMethod *string `json:"signingMethod,omitempty" tf:"signing_method,omitempty"`

	// +kubebuilder:validation:Optional
	SigningName *string `json:"signingName,omitempty" tf:"signing_name,omitempty"`

	// +kubebuilder:validation:Optional
	SigningRegion *string `json:"signingRegion,omitempty" tf:"signing_region,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type ServicesObservation struct {
}

type ServicesParameters struct {

	// +kubebuilder:validation:Optional
	Etcd []EtcdParameters `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// +kubebuilder:validation:Optional
	KubeAPI []KubeAPIParameters `json:"kubeApi,omitempty" tf:"kube_api,omitempty"`

	// +kubebuilder:validation:Optional
	KubeController []KubeControllerParameters `json:"kubeController,omitempty" tf:"kube_controller,omitempty"`

	// +kubebuilder:validation:Optional
	Kubelet []KubeletParameters `json:"kubelet,omitempty" tf:"kubelet,omitempty"`

	// +kubebuilder:validation:Optional
	Kubeproxy []KubeproxyParameters `json:"kubeproxy,omitempty" tf:"kubeproxy,omitempty"`

	// +kubebuilder:validation:Optional
	Scheduler []SchedulerParameters `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type TemplateObservation struct {
	DefaultRevisionID *string `json:"defaultRevisionId,omitempty" tf:"default_revision_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TemplateParameters struct {

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cluster template description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Cluster template members
	// +kubebuilder:validation:Optional
	Members []MembersParameters `json:"members,omitempty" tf:"members,omitempty"`

	// Cluster template revisions
	// +kubebuilder:validation:Optional
	TemplateRevisions []TemplateRevisionsParameters `json:"templateRevisions,omitempty" tf:"template_revisions,omitempty"`
}

type TemplateRevisionsObservation struct {
	ClusterTemplateID *string `json:"clusterTemplateId,omitempty" tf:"cluster_template_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TemplateRevisionsParameters struct {

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cluster configuration
	// +kubebuilder:validation:Required
	ClusterConfig []ClusterConfigParameters `json:"clusterConfig" tf:"cluster_config,omitempty"`

	// Default cluster template revision
	// +kubebuilder:validation:Optional
	Default *bool `json:"default,omitempty" tf:"default,omitempty"`

	// Enable cluster template revision
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Cluster template revision name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Cluster template questions
	// +kubebuilder:validation:Optional
	Questions []QuestionsParameters `json:"questions,omitempty" tf:"questions,omitempty"`
}

type TolerationsObservation struct {
}

type TolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type UpdateStrategyObservation struct {
}

type UpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []RollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type UpdateStrategyRollingUpdateObservation struct {
}

type UpdateStrategyRollingUpdateParameters struct {

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type UpgradeStrategyObservation struct {
}

type UpgradeStrategyParameters struct {

	// +kubebuilder:validation:Optional
	Drain *bool `json:"drain,omitempty" tf:"drain,omitempty"`

	// +kubebuilder:validation:Optional
	DrainInput []DrainInputParameters `json:"drainInput,omitempty" tf:"drain_input,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableControlplane *string `json:"maxUnavailableControlplane,omitempty" tf:"max_unavailable_controlplane,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableWorker *string `json:"maxUnavailableWorker,omitempty" tf:"max_unavailable_worker,omitempty"`
}

type VirtualCenterObservation struct {
}

type VirtualCenterParameters struct {

	// +kubebuilder:validation:Required
	Datacenters *string `json:"datacenters" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type VsphereCloudProviderGlobalObservation struct {
}

type VsphereCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Optional
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Optional
	InsecureFlag *bool `json:"insecureFlag,omitempty" tf:"insecure_flag,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type VsphereCloudProviderObservation struct {
}

type VsphereCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Global []VsphereCloudProviderGlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Required
	VirtualCenter []VirtualCenterParameters `json:"virtualCenter" tf:"virtual_center,omitempty"`

	// +kubebuilder:validation:Required
	Workspace []WorkspaceParameters `json:"workspace" tf:"workspace,omitempty"`
}

type WeaveNetworkProviderObservation struct {
}

type WeaveNetworkProviderParameters struct {

	// +kubebuilder:validation:Required
	Password *string `json:"password" tf:"password,omitempty"`
}

type WorkspaceObservation struct {
}

type WorkspaceParameters struct {

	// +kubebuilder:validation:Required
	Datacenter *string `json:"datacenter" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDatastore *string `json:"defaultDatastore,omitempty" tf:"default_datastore,omitempty"`

	// +kubebuilder:validation:Required
	Folder *string `json:"folder" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcepoolPath *string `json:"resourcepoolPath,omitempty" tf:"resourcepool_path,omitempty"`

	// +kubebuilder:validation:Required
	Server *string `json:"server" tf:"server,omitempty"`
}

// TemplateSpec defines the desired state of Template
type TemplateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TemplateParameters `json:"forProvider"`
}

// TemplateStatus defines the observed state of Template.
type TemplateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TemplateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Template is the Schema for the Templates API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type Template struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TemplateSpec   `json:"spec"`
	Status            TemplateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TemplateList contains a list of Templates
type TemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Template `json:"items"`
}

// Repository type metadata.
var (
	Template_Kind             = "Template"
	Template_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Template_Kind}.String()
	Template_KindAPIVersion   = Template_Kind + "." + CRDGroupVersion.String()
	Template_GroupVersionKind = CRDGroupVersion.WithKind(Template_Kind)
)

func init() {
	SchemeBuilder.Register(&Template{}, &TemplateList{})
}
