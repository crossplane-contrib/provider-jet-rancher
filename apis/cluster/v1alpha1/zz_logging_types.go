/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CustomTargetConfigObservation struct {
}

type CustomTargetConfigParameters struct {

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientCertSecretRef *v1.SecretKeySelector `json:"clientCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeySecretRef *v1.SecretKeySelector `json:"clientKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`
}

type ElasticsearchConfigObservation struct {
}

type ElasticsearchConfigParameters struct {

	// +kubebuilder:validation:Optional
	AuthPasswordSecretRef *v1.SecretKeySelector `json:"authPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AuthUsernameSecretRef *v1.SecretKeySelector `json:"authUsernameSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientCertSecretRef *v1.SecretKeySelector `json:"clientCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeyPassSecretRef *v1.SecretKeySelector `json:"clientKeyPassSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeySecretRef *v1.SecretKeySelector `json:"clientKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DateFormat *string `json:"dateFormat,omitempty" tf:"date_format,omitempty"`

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	IndexPrefix *string `json:"indexPrefix,omitempty" tf:"index_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	SSLVerify *bool `json:"sslVerify,omitempty" tf:"ssl_verify,omitempty"`

	// +kubebuilder:validation:Optional
	SSLVersion *string `json:"sslVersion,omitempty" tf:"ssl_version,omitempty"`
}

type FluentServersObservation struct {
}

type FluentServersParameters struct {

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SharedKeySecretRef *v1.SecretKeySelector `json:"sharedKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Standby *bool `json:"standby,omitempty" tf:"standby,omitempty"`

	// +kubebuilder:validation:Optional
	UsernameSecretRef *v1.SecretKeySelector `json:"usernameSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type FluentdConfigObservation struct {
}

type FluentdConfigParameters struct {

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Compress *bool `json:"compress,omitempty" tf:"compress,omitempty"`

	// +kubebuilder:validation:Optional
	EnableTLS *bool `json:"enableTls,omitempty" tf:"enable_tls,omitempty"`

	// +kubebuilder:validation:Required
	FluentServers []FluentServersParameters `json:"fluentServers" tf:"fluent_servers,omitempty"`
}

type KafkaConfigObservation struct {
}

type KafkaConfigParameters struct {

	// +kubebuilder:validation:Optional
	BrokerEndpoints []*string `json:"brokerEndpoints,omitempty" tf:"broker_endpoints,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientCertSecretRef *v1.SecretKeySelector `json:"clientCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeySecretRef *v1.SecretKeySelector `json:"clientKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Topic *string `json:"topic" tf:"topic,omitempty"`

	// +kubebuilder:validation:Optional
	ZookeeperEndpoint *string `json:"zookeeperEndpoint,omitempty" tf:"zookeeper_endpoint,omitempty"`
}

type LoggingObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type LoggingParameters struct {

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-rancher/apis/cluster/v1alpha2.Cluster
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CustomTargetConfig []CustomTargetConfigParameters `json:"customTargetConfig,omitempty" tf:"custom_target_config,omitempty"`

	// +kubebuilder:validation:Optional
	ElasticsearchConfig []ElasticsearchConfigParameters `json:"elasticsearchConfig,omitempty" tf:"elasticsearch_config,omitempty"`

	// Optional enable json log parsing
	// +kubebuilder:validation:Optional
	EnableJSONParsing *bool `json:"enableJsonParsing,omitempty" tf:"enable_json_parsing,omitempty"`

	// +kubebuilder:validation:Optional
	FluentdConfig []FluentdConfigParameters `json:"fluentdConfig,omitempty" tf:"fluentd_config,omitempty"`

	// +kubebuilder:validation:Optional
	KafkaConfig []KafkaConfigParameters `json:"kafkaConfig,omitempty" tf:"kafka_config,omitempty"`

	// +kubebuilder:validation:Required
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	NamespaceID *string `json:"namespaceId,omitempty" tf:"namespace_id,omitempty"`

	// +kubebuilder:validation:Optional
	OutputFlushInterval *float64 `json:"outputFlushInterval,omitempty" tf:"output_flush_interval,omitempty"`

	// +kubebuilder:validation:Optional
	OutputTags map[string]*string `json:"outputTags,omitempty" tf:"output_tags,omitempty"`

	// +kubebuilder:validation:Optional
	SplunkConfig []SplunkConfigParameters `json:"splunkConfig,omitempty" tf:"splunk_config,omitempty"`

	// +kubebuilder:validation:Optional
	SyslogConfig []SyslogConfigParameters `json:"syslogConfig,omitempty" tf:"syslog_config,omitempty"`
}

type SplunkConfigObservation struct {
}

type SplunkConfigParameters struct {

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientCertSecretRef *v1.SecretKeySelector `json:"clientCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeyPassSecretRef *v1.SecretKeySelector `json:"clientKeyPassSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeySecretRef *v1.SecretKeySelector `json:"clientKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Index *string `json:"index,omitempty" tf:"index,omitempty"`

	// +kubebuilder:validation:Optional
	SSLVerify *bool `json:"sslVerify,omitempty" tf:"ssl_verify,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Required
	TokenSecretRef v1.SecretKeySelector `json:"tokenSecretRef" tf:"-"`
}

type SyslogConfigObservation struct {
}

type SyslogConfigParameters struct {

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientCertSecretRef *v1.SecretKeySelector `json:"clientCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientKeySecretRef *v1.SecretKeySelector `json:"clientKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	EnableTLS *bool `json:"enableTls,omitempty" tf:"enable_tls,omitempty"`

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Program *string `json:"program,omitempty" tf:"program,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	SSLVerify *bool `json:"sslVerify,omitempty" tf:"ssl_verify,omitempty"`

	// +kubebuilder:validation:Optional
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// +kubebuilder:validation:Optional
	TokenSecretRef *v1.SecretKeySelector `json:"tokenSecretRef,omitempty" tf:"-"`
}

// LoggingSpec defines the desired state of Logging
type LoggingSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LoggingParameters `json:"forProvider"`
}

// LoggingStatus defines the observed state of Logging.
type LoggingStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LoggingObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Logging is the Schema for the Loggings API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type Logging struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoggingSpec   `json:"spec"`
	Status            LoggingStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LoggingList contains a list of Loggings
type LoggingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Logging `json:"items"`
}

// Repository type metadata.
var (
	Logging_Kind             = "Logging"
	Logging_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Logging_Kind}.String()
	Logging_KindAPIVersion   = Logging_Kind + "." + CRDGroupVersion.String()
	Logging_GroupVersionKind = CRDGroupVersion.WithKind(Logging_Kind)
)

func init() {
	SchemeBuilder.Register(&Logging{}, &LoggingList{})
}
