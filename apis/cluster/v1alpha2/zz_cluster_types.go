/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AgentEnvVarsObservation struct {
}

type AgentEnvVarsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type AksConfigObservation struct {
}

type AksConfigParameters struct {

	// The secret of an Azure Active Directory server application
	// +kubebuilder:validation:Optional
	AadServerAppSecretSecretRef *v1.SecretKeySelector `json:"aadServerAppSecretSecretRef,omitempty" tf:"-"`

	// The ID of an Azure Active Directory tenant
	// +kubebuilder:validation:Optional
	AadTenantIDSecretRef *v1.SecretKeySelector `json:"aadTenantIdSecretRef,omitempty" tf:"-"`

	// The ID of an Azure Active Directory client application of type "Native". This application is for user login via kubectl
	// +kubebuilder:validation:Optional
	AddClientAppIDSecretRef *v1.SecretKeySelector `json:"addClientAppIdSecretRef,omitempty" tf:"-"`

	// The ID of an Azure Active Directory server application of type "Web app/API". This application represents the managed cluster's apiserver (Server application)
	// +kubebuilder:validation:Optional
	AddServerAppIDSecretRef *v1.SecretKeySelector `json:"addServerAppIdSecretRef,omitempty" tf:"-"`

	// The administrator username to use for Linux hosts
	// +kubebuilder:validation:Optional
	AdminUsername *string `json:"adminUsername,omitempty" tf:"admin_username,omitempty"`

	// DNS prefix to be used to create the FQDN for the agent pool
	// +kubebuilder:validation:Required
	AgentDNSPrefix *string `json:"agentDnsPrefix" tf:"agent_dns_prefix,omitempty"`

	// GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
	// +kubebuilder:validation:Optional
	AgentOsDiskSize *float64 `json:"agentOsDiskSize,omitempty" tf:"agent_os_disk_size,omitempty"`

	// Name for the agent pool, upto 12 alphanumeric characters
	// +kubebuilder:validation:Optional
	AgentPoolName *string `json:"agentPoolName,omitempty" tf:"agent_pool_name,omitempty"`

	// Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
	// +kubebuilder:validation:Optional
	AgentStorageProfile *string `json:"agentStorageProfile,omitempty" tf:"agent_storage_profile,omitempty"`

	// Size of machine in the agent pool
	// +kubebuilder:validation:Optional
	AgentVMSize *string `json:"agentVmSize,omitempty" tf:"agent_vm_size,omitempty"`

	// Different authentication API url to use
	// +kubebuilder:validation:Optional
	AuthBaseURL *string `json:"authBaseUrl,omitempty" tf:"auth_base_url,omitempty"`

	// Different resource management API url to use
	// +kubebuilder:validation:Optional
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// Azure client ID to use
	// +kubebuilder:validation:Required
	ClientIDSecretRef v1.SecretKeySelector `json:"clientIdSecretRef" tf:"-"`

	// Azure client secret associated with the "client id"
	// +kubebuilder:validation:Required
	ClientSecretSecretRef v1.SecretKeySelector `json:"clientSecretSecretRef" tf:"-"`

	// Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
	// +kubebuilder:validation:Optional
	DNSServiceIP *string `json:"dnsServiceIp,omitempty" tf:"dns_service_ip,omitempty"`

	// A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
	// +kubebuilder:validation:Optional
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty" tf:"docker_bridge_cidr,omitempty"`

	// Enable the Kubernetes ingress with automatic public DNS name creation
	// +kubebuilder:validation:Optional
	EnableHTTPApplicationRouting *bool `json:"enableHttpApplicationRouting,omitempty" tf:"enable_http_application_routing,omitempty"`

	// Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
	// +kubebuilder:validation:Optional
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" tf:"enable_monitoring,omitempty"`

	// Specify the version of Kubernetes
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// Azure Kubernetes cluster location
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspace *string `json:"logAnalyticsWorkspace,omitempty" tf:"log_analytics_workspace,omitempty"`

	// The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceResourceGroup *string `json:"logAnalyticsWorkspaceResourceGroup,omitempty" tf:"log_analytics_workspace_resource_group,omitempty"`

	// DNS prefix to use the Kubernetes cluster control pane
	// +kubebuilder:validation:Required
	MasterDNSPrefix *string `json:"masterDnsPrefix" tf:"master_dns_prefix,omitempty"`

	// Maximum number of pods that can run on a node
	// +kubebuilder:validation:Optional
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
	// +kubebuilder:validation:Optional
	NetworkPlugin *string `json:"networkPlugin,omitempty" tf:"network_plugin,omitempty"`

	// Network policy used for building Kubernetes network. Chooses from [calico]
	// +kubebuilder:validation:Optional
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
	// +kubebuilder:validation:Optional
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// The name of the Cluster resource group
	// +kubebuilder:validation:Required
	ResourceGroup *string `json:"resourceGroup" tf:"resource_group,omitempty"`

	// Contents of the SSH public key used to authenticate with Linux hosts
	// +kubebuilder:validation:Required
	SSHPublicKeyContents *string `json:"sshPublicKeyContents" tf:"ssh_public_key_contents,omitempty"`

	// A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
	// +kubebuilder:validation:Optional
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
	// +kubebuilder:validation:Required
	Subnet *string `json:"subnet" tf:"subnet,omitempty"`

	// Subscription credentials which uniquely identify Microsoft Azure subscription
	// +kubebuilder:validation:Required
	SubscriptionID *string `json:"subscriptionId" tf:"subscription_id,omitempty"`

	// Tags for Kubernetes cluster. For example, foo=bar
	// +kubebuilder:validation:Optional
	Tag map[string]*string `json:"tag,omitempty" tf:"tag,omitempty"`

	// Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Azure tenant ID to use
	// +kubebuilder:validation:Required
	TenantID *string `json:"tenantId" tf:"tenant_id,omitempty"`

	// The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
	// +kubebuilder:validation:Required
	VirtualNetwork *string `json:"virtualNetwork" tf:"virtual_network,omitempty"`

	// The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
	// +kubebuilder:validation:Required
	VirtualNetworkResourceGroup *string `json:"virtualNetworkResourceGroup" tf:"virtual_network_resource_group,omitempty"`
}

type AksConfigV2Observation struct {
}

type AksConfigV2Parameters struct {

	// The AKS auth base url
	// +kubebuilder:validation:Optional
	AuthBaseURL *string `json:"authBaseUrl,omitempty" tf:"auth_base_url,omitempty"`

	// The AKS authorized ip ranges
	// +kubebuilder:validation:Optional
	AuthorizedIPRanges []*string `json:"authorizedIpRanges,omitempty" tf:"authorized_ip_ranges,omitempty"`

	// The AKS base url
	// +kubebuilder:validation:Optional
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// The AKS Cloud Credential ID to use
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-rancher/apis/rancher/v1alpha1.CloudCredential
	// +kubebuilder:validation:Optional
	CloudCredentialID *string `json:"cloudCredentialId,omitempty" tf:"cloud_credential_id,omitempty"`

	// +kubebuilder:validation:Optional
	CloudCredentialIDRef *v1.Reference `json:"cloudCredentialIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CloudCredentialIDSelector *v1.Selector `json:"cloudCredentialIdSelector,omitempty" tf:"-"`

	// The AKS dns prefix. Required if `import=false`
	// +kubebuilder:validation:Optional
	DNSPrefix *string `json:"dnsPrefix,omitempty" tf:"dns_prefix,omitempty"`

	// Enable AKS http application routing?
	// +kubebuilder:validation:Optional
	HTTPApplicationRouting *bool `json:"httpApplicationRouting,omitempty" tf:"http_application_routing,omitempty"`

	// Is AKS cluster imported?
	// +kubebuilder:validation:Optional
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The kubernetes master version. Required if `import=false`
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The AKS linux admin username
	// +kubebuilder:validation:Optional
	LinuxAdminUsername *string `json:"linuxAdminUsername,omitempty" tf:"linux_admin_username,omitempty"`

	// The AKS linux ssh public key
	// +kubebuilder:validation:Optional
	LinuxSSHPublicKey *string `json:"linuxSshPublicKey,omitempty" tf:"linux_ssh_public_key,omitempty"`

	// The AKS load balancer sku
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// The AKS log analytics workspace group
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceGroup *string `json:"logAnalyticsWorkspaceGroup,omitempty" tf:"log_analytics_workspace_group,omitempty"`

	// The AKS log analytics workspace name
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceName *string `json:"logAnalyticsWorkspaceName,omitempty" tf:"log_analytics_workspace_name,omitempty"`

	// Is AKS cluster monitoring enabled?
	// +kubebuilder:validation:Optional
	Monitoring *bool `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// The AKS cluster name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AKS network dns service ip
	// +kubebuilder:validation:Optional
	NetworkDNSServiceIP *string `json:"networkDnsServiceIp,omitempty" tf:"network_dns_service_ip,omitempty"`

	// The AKS network docker bridge cidr
	// +kubebuilder:validation:Optional
	NetworkDockerBridgeCidr *string `json:"networkDockerBridgeCidr,omitempty" tf:"network_docker_bridge_cidr,omitempty"`

	// The AKS network plugin. Required if `import=false`
	// +kubebuilder:validation:Optional
	NetworkPlugin *string `json:"networkPlugin,omitempty" tf:"network_plugin,omitempty"`

	// The AKS network pod cidr
	// +kubebuilder:validation:Optional
	NetworkPodCidr *string `json:"networkPodCidr,omitempty" tf:"network_pod_cidr,omitempty"`

	// The AKS network policy
	// +kubebuilder:validation:Optional
	NetworkPolicy *string `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`

	// The AKS network service cidr
	// +kubebuilder:validation:Optional
	NetworkServiceCidr *string `json:"networkServiceCidr,omitempty" tf:"network_service_cidr,omitempty"`

	// The AKS node pools to use. Required if `import=false`
	// +kubebuilder:validation:Optional
	NodePools []NodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`

	// Is AKS cluster private?
	// +kubebuilder:validation:Optional
	PrivateCluster *bool `json:"privateCluster,omitempty" tf:"private_cluster,omitempty"`

	// The AKS resource group
	// +kubebuilder:validation:Required
	ResourceGroup *string `json:"resourceGroup" tf:"resource_group,omitempty"`

	// The AKS resource location
	// +kubebuilder:validation:Required
	ResourceLocation *string `json:"resourceLocation" tf:"resource_location,omitempty"`

	// The AKS subnet
	// +kubebuilder:validation:Optional
	Subnet *string `json:"subnet,omitempty" tf:"subnet,omitempty"`

	// The AKS cluster tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The AKS virtual network
	// +kubebuilder:validation:Optional
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`

	// The AKS virtual network resource group
	// +kubebuilder:validation:Optional
	VirtualNetworkResourceGroup *string `json:"virtualNetworkResourceGroup,omitempty" tf:"virtual_network_resource_group,omitempty"`
}

type AuditLogObservation struct {
}

type AuditLogParameters struct {

	// +kubebuilder:validation:Optional
	Configuration []ConfigurationParameters `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AuthenticationObservation struct {
}

type AuthenticationParameters struct {

	// +kubebuilder:validation:Optional
	Sans []*string `json:"sans,omitempty" tf:"sans,omitempty"`

	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type AuthorizationObservation struct {
}

type AuthorizationParameters struct {

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`
}

type AutoscalingObservation struct {
}

type AutoscalingParameters struct {

	// Enable GKE node pool config autoscaling
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The GKE node pool config max node count
	// +kubebuilder:validation:Optional
	MaxNodeCount *float64 `json:"maxNodeCount,omitempty" tf:"max_node_count,omitempty"`

	// The GKE node pool config min node count
	// +kubebuilder:validation:Optional
	MinNodeCount *float64 `json:"minNodeCount,omitempty" tf:"min_node_count,omitempty"`
}

type AwsCloudProviderObservation struct {
}

type AwsCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Global []GlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceOverride []ServiceOverrideParameters `json:"serviceOverride,omitempty" tf:"service_override,omitempty"`
}

type AzureCloudProviderObservation struct {
}

type AzureCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AadClientCertPasswordSecretRef *v1.SecretKeySelector `json:"aadClientCertPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AadClientCertPath *string `json:"aadClientCertPath,omitempty" tf:"aad_client_cert_path,omitempty"`

	// +kubebuilder:validation:Required
	AadClientIDSecretRef v1.SecretKeySelector `json:"aadClientIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	AadClientSecretSecretRef v1.SecretKeySelector `json:"aadClientSecretSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Cloud *string `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoff *bool `json:"cloudProviderBackoff,omitempty" tf:"cloud_provider_backoff,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffDuration *float64 `json:"cloudProviderBackoffDuration,omitempty" tf:"cloud_provider_backoff_duration,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffExponent *float64 `json:"cloudProviderBackoffExponent,omitempty" tf:"cloud_provider_backoff_exponent,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffJitter *float64 `json:"cloudProviderBackoffJitter,omitempty" tf:"cloud_provider_backoff_jitter,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderBackoffRetries *float64 `json:"cloudProviderBackoffRetries,omitempty" tf:"cloud_provider_backoff_retries,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimit *bool `json:"cloudProviderRateLimit,omitempty" tf:"cloud_provider_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitBucket *float64 `json:"cloudProviderRateLimitBucket,omitempty" tf:"cloud_provider_rate_limit_bucket,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitQPS *float64 `json:"cloudProviderRateLimitQps,omitempty" tf:"cloud_provider_rate_limit_qps,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// +kubebuilder:validation:Optional
	MaximumLoadBalancerRuleCount *float64 `json:"maximumLoadBalancerRuleCount,omitempty" tf:"maximum_load_balancer_rule_count,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryAvailabilitySetName *string `json:"primaryAvailabilitySetName,omitempty" tf:"primary_availability_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryScaleSetName *string `json:"primaryScaleSetName,omitempty" tf:"primary_scale_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTableName *string `json:"routeTableName,omitempty" tf:"route_table_name,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupName *string `json:"securityGroupName,omitempty" tf:"security_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// +kubebuilder:validation:Required
	SubscriptionIDSecretRef v1.SecretKeySelector `json:"subscriptionIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	TenantIDSecretRef v1.SecretKeySelector `json:"tenantIdSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	UseInstanceMetadata *bool `json:"useInstanceMetadata,omitempty" tf:"use_instance_metadata,omitempty"`

	// +kubebuilder:validation:Optional
	UseManagedIdentityExtension *bool `json:"useManagedIdentityExtension,omitempty" tf:"use_managed_identity_extension,omitempty"`

	// +kubebuilder:validation:Optional
	VMType *string `json:"vmType,omitempty" tf:"vm_type,omitempty"`

	// +kubebuilder:validation:Optional
	VnetName *string `json:"vnetName,omitempty" tf:"vnet_name,omitempty"`

	// +kubebuilder:validation:Optional
	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty" tf:"vnet_resource_group,omitempty"`
}

type BackupConfigObservation struct {
}

type BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalHours *float64 `json:"intervalHours,omitempty" tf:"interval_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	S3BackupConfig []S3BackupConfigParameters `json:"s3BackupConfig,omitempty" tf:"s3_backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	SafeTimestamp *bool `json:"safeTimestamp,omitempty" tf:"safe_timestamp,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type BastionHostObservation struct {
}

type BastionHostParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	User *string `json:"user" tf:"user,omitempty"`
}

type BlockStorageObservation struct {
}

type BlockStorageParameters struct {

	// +kubebuilder:validation:Optional
	BsVersion *string `json:"bsVersion,omitempty" tf:"bs_version,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreVolumeAz *bool `json:"ignoreVolumeAz,omitempty" tf:"ignore_volume_az,omitempty"`

	// +kubebuilder:validation:Optional
	TrustDevicePath *bool `json:"trustDevicePath,omitempty" tf:"trust_device_path,omitempty"`
}

type CalicoNetworkProviderObservation struct {
}

type CalicoNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	CloudProvider *string `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`
}

type CanalNetworkProviderObservation struct {
}

type CanalNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type CidrBlocksObservation struct {
}

type CidrBlocksParameters struct {

	// The GKE master authorized network config cidr block
	// +kubebuilder:validation:Required
	CidrBlock *string `json:"cidrBlock" tf:"cidr_block,omitempty"`

	// The GKE master authorized network config cidr block dispaly name
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`
}

type CisScanConfigObservation struct {
}

type CisScanConfigParameters struct {

	// Debug master
	// +kubebuilder:validation:Optional
	DebugMaster *bool `json:"debugMaster,omitempty" tf:"debug_master,omitempty"`

	// Debug worker
	// +kubebuilder:validation:Optional
	DebugWorker *bool `json:"debugWorker,omitempty" tf:"debug_worker,omitempty"`

	// Override Benchmark Version
	// +kubebuilder:validation:Optional
	OverrideBenchmarkVersion *string `json:"overrideBenchmarkVersion,omitempty" tf:"override_benchmark_version,omitempty"`

	// +kubebuilder:validation:Optional
	OverrideSkip []*string `json:"overrideSkip,omitempty" tf:"override_skip,omitempty"`

	// Profile
	// +kubebuilder:validation:Optional
	Profile *string `json:"profile,omitempty" tf:"profile,omitempty"`
}

type CloudProviderObservation struct {
}

type CloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AwsCloudProvider []AwsCloudProviderParameters `json:"awsCloudProvider,omitempty" tf:"aws_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	AzureCloudProvider []AzureCloudProviderParameters `json:"azureCloudProvider,omitempty" tf:"azure_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCloudProvider *string `json:"customCloudProvider,omitempty" tf:"custom_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OpenstackCloudProvider []OpenstackCloudProviderParameters `json:"openstackCloudProvider,omitempty" tf:"openstack_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	VsphereCloudProvider []VsphereCloudProviderParameters `json:"vsphereCloudProvider,omitempty" tf:"vsphere_cloud_provider,omitempty"`
}

type ClusterAddonsObservation struct {
}

type ClusterAddonsParameters struct {

	// Enable GKE HTTP load balancing
	// +kubebuilder:validation:Optional
	HTTPLoadBalancing *bool `json:"httpLoadBalancing,omitempty" tf:"http_load_balancing,omitempty"`

	// Enable GKE horizontal pod autoscaling
	// +kubebuilder:validation:Optional
	HorizontalPodAutoscaling *bool `json:"horizontalPodAutoscaling,omitempty" tf:"horizontal_pod_autoscaling,omitempty"`

	// Enable GKE network policy config
	// +kubebuilder:validation:Optional
	NetworkPolicyConfig *bool `json:"networkPolicyConfig,omitempty" tf:"network_policy_config,omitempty"`
}

type ClusterAuthEndpointObservation struct {
}

type ClusterAuthEndpointParameters struct {

	// +kubebuilder:validation:Optional
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type ClusterMonitoringInputObservation struct {
}

type ClusterMonitoringInputParameters struct {

	// Answers for monitor input
	// +kubebuilder:validation:Optional
	Answers map[string]*string `json:"answers,omitempty" tf:"answers,omitempty"`

	// Monitoring version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClusterObservation struct {
	ClusterRegistrationToken []ClusterRegistrationTokenObservation `json:"clusterRegistrationToken,omitempty" tf:"cluster_registration_token,omitempty"`

	DefaultProjectID *string `json:"defaultProjectId,omitempty" tf:"default_project_id,omitempty"`

	EnableClusterIstio *bool `json:"enableClusterIstio,omitempty" tf:"enable_cluster_istio,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	IstioEnabled *bool `json:"istioEnabled,omitempty" tf:"istio_enabled,omitempty"`

	SystemProjectID *string `json:"systemProjectId,omitempty" tf:"system_project_id,omitempty"`
}

type ClusterParameters struct {

	// Optional Agent Env Vars for Rancher agent
	// +kubebuilder:validation:Optional
	AgentEnvVars []AgentEnvVarsParameters `json:"agentEnvVars,omitempty" tf:"agent_env_vars,omitempty"`

	// +kubebuilder:validation:Optional
	AksConfig []AksConfigParameters `json:"aksConfig,omitempty" tf:"aks_config,omitempty"`

	// +kubebuilder:validation:Optional
	AksConfigV2 []AksConfigV2Parameters `json:"aksConfigV2,omitempty" tf:"aks_config_v2,omitempty"`

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterAuthEndpoint []ClusterAuthEndpointParameters `json:"clusterAuthEndpoint,omitempty" tf:"cluster_auth_endpoint,omitempty"`

	// Cluster monitoring configuration
	// +kubebuilder:validation:Optional
	ClusterMonitoringInput []ClusterMonitoringInputParameters `json:"clusterMonitoringInput,omitempty" tf:"cluster_monitoring_input,omitempty"`

	// Cluster template answers
	// +kubebuilder:validation:Optional
	ClusterTemplateAnswers []ClusterTemplateAnswersParameters `json:"clusterTemplateAnswers,omitempty" tf:"cluster_template_answers,omitempty"`

	// Cluster template ID
	// +kubebuilder:validation:Optional
	ClusterTemplateID *string `json:"clusterTemplateId,omitempty" tf:"cluster_template_id,omitempty"`

	// Cluster template questions
	// +kubebuilder:validation:Optional
	ClusterTemplateQuestions []ClusterTemplateQuestionsParameters `json:"clusterTemplateQuestions,omitempty" tf:"cluster_template_questions,omitempty"`

	// Cluster template revision ID
	// +kubebuilder:validation:Optional
	ClusterTemplateRevisionID *string `json:"clusterTemplateRevisionId,omitempty" tf:"cluster_template_revision_id,omitempty"`

	// Default pod security policy template id
	// +kubebuilder:validation:Optional
	DefaultPodSecurityPolicyTemplateID *string `json:"defaultPodSecurityPolicyTemplateId,omitempty" tf:"default_pod_security_policy_template_id,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredAgentImage *string `json:"desiredAgentImage,omitempty" tf:"desired_agent_image,omitempty"`

	// +kubebuilder:validation:Optional
	DesiredAuthImage *string `json:"desiredAuthImage,omitempty" tf:"desired_auth_image,omitempty"`

	// +kubebuilder:validation:Optional
	DockerRootDir *string `json:"dockerRootDir,omitempty" tf:"docker_root_dir,omitempty"`

	// +kubebuilder:validation:Optional
	Driver *string `json:"driver,omitempty" tf:"driver,omitempty"`

	// +kubebuilder:validation:Optional
	EksConfig []EksConfigParameters `json:"eksConfig,omitempty" tf:"eks_config,omitempty"`

	// +kubebuilder:validation:Optional
	EksConfigV2 []EksConfigV2Parameters `json:"eksConfigV2,omitempty" tf:"eks_config_v2,omitempty"`

	// Enable built-in cluster alerting
	// +kubebuilder:validation:Optional
	EnableClusterAlerting *bool `json:"enableClusterAlerting,omitempty" tf:"enable_cluster_alerting,omitempty"`

	// Enable built-in cluster monitoring
	// +kubebuilder:validation:Optional
	EnableClusterMonitoring *bool `json:"enableClusterMonitoring,omitempty" tf:"enable_cluster_monitoring,omitempty"`

	// Enable project network isolation
	// +kubebuilder:validation:Optional
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	// +kubebuilder:validation:Optional
	FleetWorkspaceName *string `json:"fleetWorkspaceName,omitempty" tf:"fleet_workspace_name,omitempty"`

	// +kubebuilder:validation:Optional
	GkeConfig []GkeConfigParameters `json:"gkeConfig,omitempty" tf:"gke_config,omitempty"`

	// +kubebuilder:validation:Optional
	GkeConfigV2 []GkeConfigV2Parameters `json:"gkeConfigV2,omitempty" tf:"gke_config_v2,omitempty"`

	// +kubebuilder:validation:Optional
	K3SConfig []K3SConfigParameters `json:"k3sConfig,omitempty" tf:"k3s_config,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OkeConfig []OkeConfigParameters `json:"okeConfig,omitempty" tf:"oke_config,omitempty"`

	// +kubebuilder:validation:Optional
	Rke2Config []Rke2ConfigParameters `json:"rke2Config,omitempty" tf:"rke2_config,omitempty"`

	// +kubebuilder:validation:Optional
	RkeConfig []RkeConfigParameters `json:"rkeConfig,omitempty" tf:"rke_config,omitempty"`

	// Cluster scheduled scan
	// +kubebuilder:validation:Optional
	ScheduledClusterScan []ScheduledClusterScanParameters `json:"scheduledClusterScan,omitempty" tf:"scheduled_cluster_scan,omitempty"`

	// Windows preferred cluster
	// +kubebuilder:validation:Optional
	WindowsPreferedCluster *bool `json:"windowsPreferedCluster,omitempty" tf:"windows_prefered_cluster,omitempty"`
}

type ClusterRegistrationTokenObservation struct {
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InsecureCommand *string `json:"insecureCommand,omitempty" tf:"insecure_command,omitempty"`

	InsecureNodeCommand *string `json:"insecureNodeCommand,omitempty" tf:"insecure_node_command,omitempty"`

	InsecureWindowsNodeCommand *string `json:"insecureWindowsNodeCommand,omitempty" tf:"insecure_windows_node_command,omitempty"`

	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	ManifestURL *string `json:"manifestUrl,omitempty" tf:"manifest_url,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NodeCommand *string `json:"nodeCommand,omitempty" tf:"node_command,omitempty"`

	Token *string `json:"token,omitempty" tf:"token,omitempty"`

	WindowsNodeCommand *string `json:"windowsNodeCommand,omitempty" tf:"windows_node_command,omitempty"`
}

type ClusterRegistrationTokenParameters struct {
}

type ClusterTemplateAnswersObservation struct {
}

type ClusterTemplateAnswersParameters struct {

	// Cluster ID for answer
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Project ID for answer
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Key/values for answer
	// +kubebuilder:validation:Optional
	Values map[string]*string `json:"values,omitempty" tf:"values,omitempty"`
}

type ClusterTemplateQuestionsObservation struct {
}

type ClusterTemplateQuestionsParameters struct {

	// Default variable value
	// +kubebuilder:validation:Required
	Default *string `json:"default" tf:"default,omitempty"`

	// Required variable
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Variable type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Variable name
	// +kubebuilder:validation:Required
	Variable *string `json:"variable" tf:"variable,omitempty"`
}

type ConfigObservation struct {
}

type ConfigParameters struct {

	// The GKE node config disk size (Gb)
	// +kubebuilder:validation:Optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// The GKE node config disk type
	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// The GKE node config image type
	// +kubebuilder:validation:Optional
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// The GKE node config labels
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The GKE node config local ssd count
	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// The GKE node config machine type
	// +kubebuilder:validation:Optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// The GKE node config oauth scopes
	// +kubebuilder:validation:Optional
	OauthScopes []*string `json:"oauthScopes,omitempty" tf:"oauth_scopes,omitempty"`

	// Enable GKE node config preemptible
	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// The GKE node config tags
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The GKE node config taints
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`
}

type ConfigurationObservation struct {
}

type ConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBackup *float64 `json:"maxBackup,omitempty" tf:"max_backup,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type DNSObservation struct {
}

type DNSParameters struct {

	// Linear Autoscaler Params
	// +kubebuilder:validation:Optional
	LinearAutoscalerParams []LinearAutoscalerParamsParameters `json:"linearAutoscalerParams,omitempty" tf:"linear_autoscaler_params,omitempty"`

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Nodelocal dns
	// +kubebuilder:validation:Optional
	Nodelocal []NodelocalParameters `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	ReverseCidrs []*string `json:"reverseCidrs,omitempty" tf:"reverse_cidrs,omitempty"`

	// DNS service tolerations
	// +kubebuilder:validation:Optional
	Tolerations []TolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []UpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	UpstreamNameservers []*string `json:"upstreamNameservers,omitempty" tf:"upstream_nameservers,omitempty"`
}

type DiskObservation struct {
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	ScsiControllerType *string `json:"scsiControllerType,omitempty" tf:"scsi_controller_type,omitempty"`
}

type DrainInputObservation struct {
}

type DrainInputParameters struct {

	// +kubebuilder:validation:Optional
	DeleteLocalData *bool `json:"deleteLocalData,omitempty" tf:"delete_local_data,omitempty"`

	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type EcrCredentialPluginObservation struct {
}

type EcrCredentialPluginParameters struct {

	// +kubebuilder:validation:Optional
	AwsAccessKeyID *string `json:"awsAccessKeyId,omitempty" tf:"aws_access_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	AwsSecretAccessKeySecretRef *v1.SecretKeySelector `json:"awsSecretAccessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	AwsSessionTokenSecretRef *v1.SecretKeySelector `json:"awsSessionTokenSecretRef,omitempty" tf:"-"`
}

type EksConfigObservation struct {
}

type EksConfigParameters struct {

	// A custom AMI ID to use for the worker nodes instead of the default
	// +kubebuilder:validation:Optional
	AMI *string `json:"ami,omitempty" tf:"ami,omitempty"`

	// The AWS Client ID to use
	// +kubebuilder:validation:Required
	AccessKeySecretRef v1.SecretKeySelector `json:"accessKeySecretRef" tf:"-"`

	// Associate public ip EKS worker nodes
	// +kubebuilder:validation:Optional
	AssociateWorkerNodePublicIP *bool `json:"associateWorkerNodePublicIp,omitempty" tf:"associate_worker_node_public_ip,omitempty"`

	// The desired number of worker nodes
	// +kubebuilder:validation:Optional
	DesiredNodes *float64 `json:"desiredNodes,omitempty" tf:"desired_nodes,omitempty"`

	// Enables EBS encryption of worker nodes
	// +kubebuilder:validation:Optional
	EBSEncryption *bool `json:"ebsEncryption,omitempty" tf:"ebs_encryption,omitempty"`

	// The type of machine to use for worker nodes
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// Allow user to specify key name to use
	// +kubebuilder:validation:Optional
	KeyPairName *string `json:"keyPairName,omitempty" tf:"key_pair_name,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// The maximum number of worker nodes
	// +kubebuilder:validation:Optional
	MaximumNodes *float64 `json:"maximumNodes,omitempty" tf:"maximum_nodes,omitempty"`

	// The minimum number of worker nodes
	// +kubebuilder:validation:Optional
	MinimumNodes *float64 `json:"minimumNodes,omitempty" tf:"minimum_nodes,omitempty"`

	// The volume size for each node
	// +kubebuilder:validation:Optional
	NodeVolumeSize *float64 `json:"nodeVolumeSize,omitempty" tf:"node_volume_size,omitempty"`

	// The AWS Region to create the EKS cluster in
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The AWS Client Secret associated with the Client ID
	// +kubebuilder:validation:Required
	SecretKeySecretRef v1.SecretKeySelector `json:"secretKeySecretRef" tf:"-"`

	// List of security groups to use for the cluster
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The service role to use to perform the cluster operations in AWS
	// +kubebuilder:validation:Optional
	ServiceRole *string `json:"serviceRole,omitempty" tf:"service_role,omitempty"`

	// A session token to use with the client key and secret if applicable
	// +kubebuilder:validation:Optional
	SessionTokenSecretRef *v1.SecretKeySelector `json:"sessionTokenSecretRef,omitempty" tf:"-"`

	// List of subnets in the virtual network to use
	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// Pass user-data to the nodes to perform automated configuration tasks
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The name of the virtual network to use
	// +kubebuilder:validation:Optional
	VirtualNetwork *string `json:"virtualNetwork,omitempty" tf:"virtual_network,omitempty"`
}

type EksConfigV2Observation struct {
}

type EksConfigV2Parameters struct {

	// The AWS Cloud Credential ID to use
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-rancher/apis/rancher/v1alpha1.CloudCredential
	// +kubebuilder:validation:Optional
	CloudCredentialID *string `json:"cloudCredentialId,omitempty" tf:"cloud_credential_id,omitempty"`

	// +kubebuilder:validation:Optional
	CloudCredentialIDRef *v1.Reference `json:"cloudCredentialIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CloudCredentialIDSelector *v1.Selector `json:"cloudCredentialIdSelector,omitempty" tf:"-"`

	// Is EKS cluster imported?
	// +kubebuilder:validation:Optional
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The AWS kms key to use
	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The AWS logging types
	// +kubebuilder:validation:Optional
	LoggingTypes []*string `json:"loggingTypes,omitempty" tf:"logging_types,omitempty"`

	// The EKS cluster name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The AWS node groups to use
	// +kubebuilder:validation:Optional
	NodeGroups []NodeGroupsParameters `json:"nodeGroups,omitempty" tf:"node_groups,omitempty"`

	// The EKS cluster has private access
	// +kubebuilder:validation:Optional
	PrivateAccess *bool `json:"privateAccess,omitempty" tf:"private_access,omitempty"`

	// The EKS cluster has public access
	// +kubebuilder:validation:Optional
	PublicAccess *bool `json:"publicAccess,omitempty" tf:"public_access,omitempty"`

	// The EKS cluster public access sources
	// +kubebuilder:validation:Optional
	PublicAccessSources []*string `json:"publicAccessSources,omitempty" tf:"public_access_sources,omitempty"`

	// The AWS Region to create the EKS cluster in
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Enable EKS cluster secret encryption
	// +kubebuilder:validation:Optional
	SecretsEncryption *bool `json:"secretsEncryption,omitempty" tf:"secrets_encryption,omitempty"`

	// List of security groups to use for the cluster
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// The AWS service role to use
	// +kubebuilder:validation:Optional
	ServiceRole *string `json:"serviceRole,omitempty" tf:"service_role,omitempty"`

	// List of subnets in the virtual network to use
	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// The EKS cluster tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type EtcdObservation struct {
}

type EtcdParameters struct {

	// +kubebuilder:validation:Optional
	BackupConfig []BackupConfigParameters `json:"backupConfig,omitempty" tf:"backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	CACert *string `json:"caCert,omitempty" tf:"ca_cert,omitempty"`

	// +kubebuilder:validation:Optional
	CertSecretRef *v1.SecretKeySelector `json:"certSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Creation *string `json:"creation,omitempty" tf:"creation,omitempty"`

	// +kubebuilder:validation:Optional
	ExternalUrls []*string `json:"externalUrls,omitempty" tf:"external_urls,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	GID *float64 `json:"gid,omitempty" tf:"gid,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	KeySecretRef *v1.SecretKeySelector `json:"keySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *string `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	Snapshot *bool `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	// +kubebuilder:validation:Optional
	UID *float64 `json:"uid,omitempty" tf:"uid,omitempty"`
}

type EventRateLimitObservation struct {
}

type EventRateLimitParameters struct {

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type FlannelNetworkProviderObservation struct {
}

type FlannelNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type GkeConfigObservation struct {
}

type GkeConfigParameters struct {

	// The IP address range of the container pods
	// +kubebuilder:validation:Required
	ClusterIPv4Cidr *string `json:"clusterIpv4Cidr" tf:"cluster_ipv4_cidr,omitempty"`

	// The contents of the GC credential file
	// +kubebuilder:validation:Required
	CredentialSecretRef v1.SecretKeySelector `json:"credentialSecretRef" tf:"-"`

	// An optional description of this cluster
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Size of the disk attached to each node
	// +kubebuilder:validation:Optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// Type of the disk attached to each node
	// +kubebuilder:validation:Required
	DiskType *string `json:"diskType" tf:"disk_type,omitempty"`

	// To enable kubernetes alpha feature
	// +kubebuilder:validation:Optional
	EnableAlphaFeature *bool `json:"enableAlphaFeature,omitempty" tf:"enable_alpha_feature,omitempty"`

	// Specifies whether the node auto-repair is enabled for the node pool
	// +kubebuilder:validation:Optional
	EnableAutoRepair *bool `json:"enableAutoRepair,omitempty" tf:"enable_auto_repair,omitempty"`

	// Specifies whether node auto-upgrade is enabled for the node pool
	// +kubebuilder:validation:Optional
	EnableAutoUpgrade *bool `json:"enableAutoUpgrade,omitempty" tf:"enable_auto_upgrade,omitempty"`

	// Enable http load balancing for the cluster
	// +kubebuilder:validation:Optional
	EnableHTTPLoadBalancing *bool `json:"enableHttpLoadBalancing,omitempty" tf:"enable_http_load_balancing,omitempty"`

	// Enable horizontal pod autoscaling for the cluster
	// +kubebuilder:validation:Optional
	EnableHorizontalPodAutoscaling *bool `json:"enableHorizontalPodAutoscaling,omitempty" tf:"enable_horizontal_pod_autoscaling,omitempty"`

	// Whether to enable the kubernetes dashboard
	// +kubebuilder:validation:Optional
	EnableKubernetesDashboard *bool `json:"enableKubernetesDashboard,omitempty" tf:"enable_kubernetes_dashboard,omitempty"`

	// Whether to enable legacy abac on the cluster
	// +kubebuilder:validation:Optional
	EnableLegacyAbac *bool `json:"enableLegacyAbac,omitempty" tf:"enable_legacy_abac,omitempty"`

	// Whether or not master authorized network is enabled
	// +kubebuilder:validation:Optional
	EnableMasterAuthorizedNetwork *bool `json:"enableMasterAuthorizedNetwork,omitempty" tf:"enable_master_authorized_network,omitempty"`

	// Enable network policy config for the cluster
	// +kubebuilder:validation:Optional
	EnableNetworkPolicyConfig *bool `json:"enableNetworkPolicyConfig,omitempty" tf:"enable_network_policy_config,omitempty"`

	// Enable nodepool autoscaling
	// +kubebuilder:validation:Optional
	EnableNodepoolAutoscaling *bool `json:"enableNodepoolAutoscaling,omitempty" tf:"enable_nodepool_autoscaling,omitempty"`

	// Whether the master's internal IP address is used as the cluster endpoint
	// +kubebuilder:validation:Optional
	EnablePrivateEndpoint *bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`

	// Whether nodes have internal IP address only
	// +kubebuilder:validation:Optional
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// Enable stackdriver logging
	// +kubebuilder:validation:Optional
	EnableStackdriverLogging *bool `json:"enableStackdriverLogging,omitempty" tf:"enable_stackdriver_logging,omitempty"`

	// Enable stackdriver monitoring
	// +kubebuilder:validation:Optional
	EnableStackdriverMonitoring *bool `json:"enableStackdriverMonitoring,omitempty" tf:"enable_stackdriver_monitoring,omitempty"`

	// The IP address range for the cluster pod IPs
	// +kubebuilder:validation:Required
	IPPolicyClusterIPv4CidrBlock *string `json:"ipPolicyClusterIpv4CidrBlock" tf:"ip_policy_cluster_ipv4_cidr_block,omitempty"`

	// The name of the secondary range to be used for the cluster CIDR block
	// +kubebuilder:validation:Required
	IPPolicyClusterSecondaryRangeName *string `json:"ipPolicyClusterSecondaryRangeName" tf:"ip_policy_cluster_secondary_range_name,omitempty"`

	// Whether a new subnetwork will be created automatically for the cluster
	// +kubebuilder:validation:Optional
	IPPolicyCreateSubnetwork *bool `json:"ipPolicyCreateSubnetwork,omitempty" tf:"ip_policy_create_subnetwork,omitempty"`

	// The IP address range of the instance IPs in this cluster
	// +kubebuilder:validation:Required
	IPPolicyNodeIPv4CidrBlock *string `json:"ipPolicyNodeIpv4CidrBlock" tf:"ip_policy_node_ipv4_cidr_block,omitempty"`

	// The IP address range of the services IPs in this cluster
	// +kubebuilder:validation:Required
	IPPolicyServicesIPv4CidrBlock *string `json:"ipPolicyServicesIpv4CidrBlock" tf:"ip_policy_services_ipv4_cidr_block,omitempty"`

	// The name of the secondary range to be used for the services CIDR block
	// +kubebuilder:validation:Required
	IPPolicyServicesSecondaryRangeName *string `json:"ipPolicyServicesSecondaryRangeName" tf:"ip_policy_services_secondary_range_name,omitempty"`

	// A custom subnetwork name to be used if createSubnetwork is true
	// +kubebuilder:validation:Required
	IPPolicySubnetworkName *string `json:"ipPolicySubnetworkName" tf:"ip_policy_subnetwork_name,omitempty"`

	// The image to use for the worker nodes
	// +kubebuilder:validation:Required
	ImageType *string `json:"imageType" tf:"image_type,omitempty"`

	// Issue a client certificate
	// +kubebuilder:validation:Optional
	IssueClientCertificate *bool `json:"issueClientCertificate,omitempty" tf:"issue_client_certificate,omitempty"`

	// Enable the kubernetes dashboard
	// +kubebuilder:validation:Optional
	KubernetesDashboard *bool `json:"kubernetesDashboard,omitempty" tf:"kubernetes_dashboard,omitempty"`

	// The map of Kubernetes labels (key/value pairs) to be applied to each node
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The number of local SSD disks to be attached to the node
	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Locations to use for the cluster
	// +kubebuilder:validation:Required
	Locations []*string `json:"locations" tf:"locations,omitempty"`

	// The machine type to use for the worker nodes
	// +kubebuilder:validation:Required
	MachineType *string `json:"machineType" tf:"machine_type,omitempty"`

	// When to performance updates on the nodes, in 24-hour time
	// +kubebuilder:validation:Required
	MaintenanceWindow *string `json:"maintenanceWindow" tf:"maintenance_window,omitempty"`

	// Define up to 10 external networks that could access Kubernetes master through HTTPS
	// +kubebuilder:validation:Optional
	MasterAuthorizedNetworkCidrBlocks []*string `json:"masterAuthorizedNetworkCidrBlocks,omitempty" tf:"master_authorized_network_cidr_blocks,omitempty"`

	// The IP range in CIDR notation to use for the hosted master network
	// +kubebuilder:validation:Required
	MasterIPv4CidrBlock *string `json:"masterIpv4CidrBlock" tf:"master_ipv4_cidr_block,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Required
	MasterVersion *string `json:"masterVersion" tf:"master_version,omitempty"`

	// Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
	// +kubebuilder:validation:Optional
	MaxNodeCount *float64 `json:"maxNodeCount,omitempty" tf:"max_node_count,omitempty"`

	// Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
	// +kubebuilder:validation:Optional
	MinNodeCount *float64 `json:"minNodeCount,omitempty" tf:"min_node_count,omitempty"`

	// The network to use for the cluster
	// +kubebuilder:validation:Required
	Network *string `json:"network" tf:"network,omitempty"`

	// The number of nodes to create in this cluster
	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// The ID of the cluster node pool
	// +kubebuilder:validation:Required
	NodePool *string `json:"nodePool" tf:"node_pool,omitempty"`

	// The version of kubernetes to use on the nodes
	// +kubebuilder:validation:Required
	NodeVersion *string `json:"nodeVersion" tf:"node_version,omitempty"`

	// The set of Google API scopes to be made available on all of the node VMs under the default service account
	// +kubebuilder:validation:Required
	OauthScopes []*string `json:"oauthScopes" tf:"oauth_scopes,omitempty"`

	// Whether the nodes are created as preemptible VM instances
	// +kubebuilder:validation:Optional
	Preemptible *bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`

	// The ID of your project to use when creating a cluster
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// The region to launch the cluster. Region or zone should be used
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The map of Kubernetes labels (key/value pairs) to be applied to each cluster
	// +kubebuilder:validation:Optional
	ResourceLabels map[string]*string `json:"resourceLabels,omitempty" tf:"resource_labels,omitempty"`

	// The Google Cloud Platform Service Account to be used by the node VMs
	// +kubebuilder:validation:Required
	ServiceAccount *string `json:"serviceAccount" tf:"service_account,omitempty"`

	// The sub-network to use for the cluster
	// +kubebuilder:validation:Required
	SubNetwork *string `json:"subNetwork" tf:"sub_network,omitempty"`

	// List of kubernetes taints to be applied to each node
	// +kubebuilder:validation:Optional
	Taints []*string `json:"taints,omitempty" tf:"taints,omitempty"`

	// Whether alias IPs will be used for pod IPs in the cluster
	// +kubebuilder:validation:Optional
	UseIPAliases *bool `json:"useIpAliases,omitempty" tf:"use_ip_aliases,omitempty"`

	// The zone to launch the cluster. Zone or region should be used
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GkeConfigV2NodePoolsObservation struct {
}

type GkeConfigV2NodePoolsParameters struct {

	// The GKE node pool config autoscaling
	// +kubebuilder:validation:Optional
	Autoscaling []AutoscalingParameters `json:"autoscaling,omitempty" tf:"autoscaling,omitempty"`

	// The GKE node pool node config
	// +kubebuilder:validation:Optional
	Config []ConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// The GKE node pool config initial node count
	// +kubebuilder:validation:Required
	InitialNodeCount *float64 `json:"initialNodeCount" tf:"initial_node_count,omitempty"`

	// The GKE node pool config management
	// +kubebuilder:validation:Optional
	Management []ManagementParameters `json:"management,omitempty" tf:"management,omitempty"`

	// The GKE node pool config max pods constraint
	// +kubebuilder:validation:Optional
	MaxPodsConstraint *float64 `json:"maxPodsConstraint,omitempty" tf:"max_pods_constraint,omitempty"`

	// The GKE node pool config name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The GKE node pool config version
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type GkeConfigV2Observation struct {
}

type GkeConfigV2Parameters struct {

	// +kubebuilder:validation:Optional
	CloudCredentialIdRef *v1.Reference `json:"cloudCredentialIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CloudCredentialIdSelector *v1.Selector `json:"cloudCredentialIdSelector,omitempty" tf:"-"`

	// The GKE cluster addons
	// +kubebuilder:validation:Optional
	ClusterAddons []ClusterAddonsParameters `json:"clusterAddons,omitempty" tf:"cluster_addons,omitempty"`

	// The GKE ip v4 cidr block
	// +kubebuilder:validation:Optional
	ClusterIPv4CidrBlock *string `json:"clusterIpv4CidrBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`

	// The GKE cluster description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable Kubernetes alpha
	// +kubebuilder:validation:Optional
	EnableKubernetesAlpha *bool `json:"enableKubernetesAlpha,omitempty" tf:"enable_kubernetes_alpha,omitempty"`

	// The GKE Cloud Credential ID to use
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-rancher/apis/rancher/v1alpha1.CloudCredential
	// +crossplane:generate:reference:refFieldName=CloudCredentialIdRef
	// +crossplane:generate:reference:selectorFieldName=CloudCredentialIdSelector
	// +kubebuilder:validation:Optional
	GoogleCredentialSecret *string `json:"googleCredentialSecret,omitempty" tf:"google_credential_secret,omitempty"`

	// The GKE ip allocation policy
	// +kubebuilder:validation:Optional
	IPAllocationPolicy []IPAllocationPolicyParameters `json:"ipAllocationPolicy,omitempty" tf:"ip_allocation_policy,omitempty"`

	// Is GKE cluster imported?
	// +kubebuilder:validation:Optional
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// The kubernetes master version
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// The GKE cluster labels
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The GKE cluster locations
	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`

	// The GKE cluster logging service
	// +kubebuilder:validation:Optional
	LoggingService *string `json:"loggingService,omitempty" tf:"logging_service,omitempty"`

	// The GKE cluster maintenance window
	// +kubebuilder:validation:Optional
	MaintenanceWindow *string `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// The GKE cluster master authorized networks config
	// +kubebuilder:validation:Optional
	MasterAuthorizedNetworksConfig []MasterAuthorizedNetworksConfigParameters `json:"masterAuthorizedNetworksConfig,omitempty" tf:"master_authorized_networks_config,omitempty"`

	// The GKE cluster monitoring service
	// +kubebuilder:validation:Optional
	MonitoringService *string `json:"monitoringService,omitempty" tf:"monitoring_service,omitempty"`

	// The GKE cluster name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The GKE cluster network
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Is GKE cluster network policy enabled?
	// +kubebuilder:validation:Optional
	NetworkPolicyEnabled *bool `json:"networkPolicyEnabled,omitempty" tf:"network_policy_enabled,omitempty"`

	// The GKE cluster node pools
	// +kubebuilder:validation:Optional
	NodePools []GkeConfigV2NodePoolsParameters `json:"nodePools,omitempty" tf:"node_pools,omitempty"`

	// The GKE private cluster config
	// +kubebuilder:validation:Optional
	PrivateClusterConfig []PrivateClusterConfigParameters `json:"privateClusterConfig,omitempty" tf:"private_cluster_config,omitempty"`

	// The GKE project id
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// The GKE cluster region. Required if `zone` is empty
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The GKE cluster subnetwork
	// +kubebuilder:validation:Optional
	Subnetwork *string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`

	// The GKE cluster zone. Required if `region` is empty
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type GlobalObservation struct {
}

type GlobalParameters struct {

	// +kubebuilder:validation:Optional
	DisableSecurityGroupIngress *bool `json:"disableSecurityGroupIngress,omitempty" tf:"disable_security_group_ingress,omitempty"`

	// +kubebuilder:validation:Optional
	DisableStrictZoneCheck *bool `json:"disableStrictZoneCheck,omitempty" tf:"disable_strict_zone_check,omitempty"`

	// +kubebuilder:validation:Optional
	ELBSecurityGroup *string `json:"elbSecurityGroup,omitempty" tf:"elb_security_group,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesClusterID *string `json:"kubernetesClusterId,omitempty" tf:"kubernetes_cluster_id,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesClusterTag *string `json:"kubernetesClusterTag,omitempty" tf:"kubernetes_cluster_tag,omitempty"`

	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`

	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type IPAllocationPolicyObservation struct {
}

type IPAllocationPolicyParameters struct {

	// The GKE cluster ip v4 allocation cidr block
	// +kubebuilder:validation:Optional
	ClusterIPv4CidrBlock *string `json:"clusterIpv4CidrBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`

	// The GKE cluster ip v4 allocation secondary range name
	// +kubebuilder:validation:Optional
	ClusterSecondaryRangeName *string `json:"clusterSecondaryRangeName,omitempty" tf:"cluster_secondary_range_name,omitempty"`

	// Create GKE subnetwork?
	// +kubebuilder:validation:Optional
	CreateSubnetwork *bool `json:"createSubnetwork,omitempty" tf:"create_subnetwork,omitempty"`

	// The GKE node ip v4 allocation cidr block
	// +kubebuilder:validation:Optional
	NodeIPv4CidrBlock *string `json:"nodeIpv4CidrBlock,omitempty" tf:"node_ipv4_cidr_block,omitempty"`

	// The GKE services ip v4 allocation cidr block
	// +kubebuilder:validation:Optional
	ServicesIPv4CidrBlock *string `json:"servicesIpv4CidrBlock,omitempty" tf:"services_ipv4_cidr_block,omitempty"`

	// The GKE services ip v4 allocation secondary range name
	// +kubebuilder:validation:Optional
	ServicesSecondaryRangeName *string `json:"servicesSecondaryRangeName,omitempty" tf:"services_secondary_range_name,omitempty"`

	// The GKE cluster subnetwork name
	// +kubebuilder:validation:Optional
	SubnetworkName *string `json:"subnetworkName,omitempty" tf:"subnetwork_name,omitempty"`

	// Use GKE ip aliases?
	// +kubebuilder:validation:Optional
	UseIPAliases *bool `json:"useIpAliases,omitempty" tf:"use_ip_aliases,omitempty"`
}

type IngressObservation struct {
}

type IngressParameters struct {

	// +kubebuilder:validation:Optional
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultBackend *bool `json:"defaultBackend,omitempty" tf:"default_backend,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPPort *float64 `json:"httpPort,omitempty" tf:"http_port,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPSPort *float64 `json:"httpsPort,omitempty" tf:"https_port,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode,omitempty"`

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// Ingress add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []IngressTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update daemon set strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []IngressUpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type IngressTolerationsObservation struct {
}

type IngressTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IngressUpdateStrategyObservation struct {
}

type IngressUpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []UpdateStrategyRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type K3SConfigObservation struct {
}

type K3SConfigParameters struct {

	// The K3S upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []UpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// The K3S kubernetes version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type KubeAPIObservation struct {
}

type KubeAPIParameters struct {

	// +kubebuilder:validation:Optional
	AdmissionConfiguration map[string]*string `json:"admissionConfiguration,omitempty" tf:"admission_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysPullImages *bool `json:"alwaysPullImages,omitempty" tf:"always_pull_images,omitempty"`

	// +kubebuilder:validation:Optional
	AuditLog []AuditLogParameters `json:"auditLog,omitempty" tf:"audit_log,omitempty"`

	// +kubebuilder:validation:Optional
	EventRateLimit []EventRateLimitParameters `json:"eventRateLimit,omitempty" tf:"event_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecretsEncryptionConfig []SecretsEncryptionConfigParameters `json:"secretsEncryptionConfig,omitempty" tf:"secrets_encryption_config,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceNodePortRange *string `json:"serviceNodePortRange,omitempty" tf:"service_node_port_range,omitempty"`
}

type KubeControllerObservation struct {
}

type KubeControllerParameters struct {

	// +kubebuilder:validation:Optional
	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`
}

type KubeletObservation struct {
}

type KubeletParameters struct {

	// +kubebuilder:validation:Optional
	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	FailSwapOn *bool `json:"failSwapOn,omitempty" tf:"fail_swap_on,omitempty"`

	// +kubebuilder:validation:Optional
	GenerateServingCertificate *bool `json:"generateServingCertificate,omitempty" tf:"generate_serving_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	InfraContainerImage *string `json:"infraContainerImage,omitempty" tf:"infra_container_image,omitempty"`
}

type KubeproxyObservation struct {
}

type KubeproxyParameters struct {

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type LaunchTemplateObservation struct {
}

type LaunchTemplateParameters struct {

	// The EKS node group launch template ID
	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// The EKS node group launch template name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The EKS node group launch template version
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type LinearAutoscalerParamsObservation struct {
}

type LinearAutoscalerParamsParameters struct {

	// +kubebuilder:validation:Optional
	CoresPerReplica *float64 `json:"coresPerReplica,omitempty" tf:"cores_per_replica,omitempty"`

	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`

	// +kubebuilder:validation:Optional
	NodesPerReplica *float64 `json:"nodesPerReplica,omitempty" tf:"nodes_per_replica,omitempty"`

	// +kubebuilder:validation:Optional
	PreventSinglePointFailure *bool `json:"preventSinglePointFailure,omitempty" tf:"prevent_single_point_failure,omitempty"`
}

type LoadBalancerObservation struct {
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	CreateMonitor *bool `json:"createMonitor,omitempty" tf:"create_monitor,omitempty"`

	// +kubebuilder:validation:Optional
	FloatingNetworkID *string `json:"floatingNetworkId,omitempty" tf:"floating_network_id,omitempty"`

	// +kubebuilder:validation:Optional
	LBMethod *string `json:"lbMethod,omitempty" tf:"lb_method,omitempty"`

	// +kubebuilder:validation:Optional
	LBProvider *string `json:"lbProvider,omitempty" tf:"lb_provider,omitempty"`

	// +kubebuilder:validation:Optional
	LBVersion *string `json:"lbVersion,omitempty" tf:"lb_version,omitempty"`

	// +kubebuilder:validation:Optional
	ManageSecurityGroups *bool `json:"manageSecurityGroups,omitempty" tf:"manage_security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorDelay *string `json:"monitorDelay,omitempty" tf:"monitor_delay,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorMaxRetries *float64 `json:"monitorMaxRetries,omitempty" tf:"monitor_max_retries,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorTimeout *string `json:"monitorTimeout,omitempty" tf:"monitor_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	UseOctavia *bool `json:"useOctavia,omitempty" tf:"use_octavia,omitempty"`
}

type ManagementObservation struct {
}

type ManagementParameters struct {

	// Enable GKE node pool config management auto repair
	// +kubebuilder:validation:Optional
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Enable GKE node pool config management auto upgrade
	// +kubebuilder:validation:Optional
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`
}

type MasterAuthorizedNetworksConfigObservation struct {
}

type MasterAuthorizedNetworksConfigParameters struct {

	// The GKE master authorized network config cidr blocks
	// +kubebuilder:validation:Required
	CidrBlocks []CidrBlocksParameters `json:"cidrBlocks" tf:"cidr_blocks,omitempty"`

	// Enable GKE master authorized network config
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type MetadataObservation struct {
}

type MetadataParameters struct {

	// +kubebuilder:validation:Optional
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SearchOrder *string `json:"searchOrder,omitempty" tf:"search_order,omitempty"`
}

type MonitoringObservation struct {
}

type MonitoringParameters struct {

	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// +kubebuilder:validation:Optional
	Replicas *float64 `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// Monitoring add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []MonitoringTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// Update deployment strategy
	// +kubebuilder:validation:Optional
	UpdateStrategy []MonitoringUpdateStrategyParameters `json:"updateStrategy,omitempty" tf:"update_strategy,omitempty"`
}

type MonitoringTolerationsObservation struct {
}

type MonitoringTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MonitoringUpdateStrategyObservation struct {
}

type MonitoringUpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []MonitoringUpdateStrategyRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type MonitoringUpdateStrategyRollingUpdateObservation struct {
}

type MonitoringUpdateStrategyRollingUpdateParameters struct {

	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type NetworkObservation struct {
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	PublicNetwork *string `json:"publicNetwork,omitempty" tf:"public_network,omitempty"`
}

type NetworkTolerationsObservation struct {
}

type NetworkTolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type NodeGroupsObservation struct {
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NodeGroupsParameters struct {

	// The EKS node group desired size
	// +kubebuilder:validation:Optional
	DesiredSize *float64 `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// The EKS node group disk size
	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// The EKS node group ssh key
	// +kubebuilder:validation:Optional
	EC2SSHKey *string `json:"ec2SshKey,omitempty" tf:"ec2_ssh_key,omitempty"`

	// Is EKS cluster using gpu?
	// +kubebuilder:validation:Optional
	Gpu *bool `json:"gpu,omitempty" tf:"gpu,omitempty"`

	// The EKS node group image ID
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The EKS node group instance type
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The EKS node group tags
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The EKS node groups launch template
	// +kubebuilder:validation:Optional
	LaunchTemplate []LaunchTemplateParameters `json:"launchTemplate,omitempty" tf:"launch_template,omitempty"`

	// The EKS node group maximum size
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// The EKS node group minimum size
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The EKS node group name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Enable EKS node group request spot instances
	// +kubebuilder:validation:Optional
	RequestSpotInstances *bool `json:"requestSpotInstances,omitempty" tf:"request_spot_instances,omitempty"`

	// The EKS node group resource tags
	// +kubebuilder:validation:Optional
	ResourceTags map[string]*string `json:"resourceTags,omitempty" tf:"resource_tags,omitempty"`

	// The EKS node group spot instace types
	// +kubebuilder:validation:Optional
	SpotInstanceTypes []*string `json:"spotInstanceTypes,omitempty" tf:"spot_instance_types,omitempty"`

	// The EKS node group subnets
	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// The EKS node group tags
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The EKS node group user data
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type NodePoolsObservation struct {
}

type NodePoolsParameters struct {

	// The AKS node pool availability zones
	// +kubebuilder:validation:Optional
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// The AKS node pool count
	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// Is AKS node pool auto scaling enabled?
	// +kubebuilder:validation:Optional
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty" tf:"enable_auto_scaling,omitempty"`

	// The AKS node pool max count
	// +kubebuilder:validation:Optional
	MaxCount *float64 `json:"maxCount,omitempty" tf:"max_count,omitempty"`

	// The AKS node pool max pods
	// +kubebuilder:validation:Optional
	MaxPods *float64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// The AKS node pool min count
	// +kubebuilder:validation:Optional
	MinCount *float64 `json:"minCount,omitempty" tf:"min_count,omitempty"`

	// The AKS node pool mode
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The AKS node group name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The AKS node pool orchestrator version
	// +kubebuilder:validation:Optional
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty" tf:"orchestrator_version,omitempty"`

	// The AKS node pool os disk size gb
	// +kubebuilder:validation:Optional
	OsDiskSizeGb *float64 `json:"osDiskSizeGb,omitempty" tf:"os_disk_size_gb,omitempty"`

	// The AKS node pool os disk type
	// +kubebuilder:validation:Optional
	OsDiskType *string `json:"osDiskType,omitempty" tf:"os_disk_type,omitempty"`

	// Enable AKS node pool os type
	// +kubebuilder:validation:Optional
	OsType *string `json:"osType,omitempty" tf:"os_type,omitempty"`

	// The AKS node pool vm size
	// +kubebuilder:validation:Optional
	VMSize *string `json:"vmSize,omitempty" tf:"vm_size,omitempty"`
}

type NodelocalObservation struct {
}

type NodelocalParameters struct {

	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Node selector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`
}

type NodesObservation struct {
}

type NodesParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	DockerSocket *string `json:"dockerSocket,omitempty" tf:"docker_socket,omitempty"`

	// +kubebuilder:validation:Optional
	HostnameOverride *string `json:"hostnameOverride,omitempty" tf:"hostname_override,omitempty"`

	// +kubebuilder:validation:Optional
	InternalAddress *string `json:"internalAddress,omitempty" tf:"internal_address,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	NodeID *string `json:"nodeId,omitempty" tf:"node_id,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Role []*string `json:"role" tf:"role,omitempty"`

	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type OkeConfigObservation struct {
}

type OkeConfigParameters struct {

	// The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
	// +kubebuilder:validation:Required
	CompartmentID *string `json:"compartmentId" tf:"compartment_id,omitempty"`

	// An optional custom boot volume size (in GB) for the nodes
	// +kubebuilder:validation:Optional
	CustomBootVolumeSize *float64 `json:"customBootVolumeSize,omitempty" tf:"custom_boot_volume_size,omitempty"`

	// An optional description of this cluster
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable the kubernetes dashboard
	// +kubebuilder:validation:Optional
	EnableKubernetesDashboard *bool `json:"enableKubernetesDashboard,omitempty" tf:"enable_kubernetes_dashboard,omitempty"`

	// Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
	// +kubebuilder:validation:Optional
	EnablePrivateControlPlane *bool `json:"enablePrivateControlPlane,omitempty" tf:"enable_private_control_plane,omitempty"`

	// Whether worker nodes are deployed into a new private subnet
	// +kubebuilder:validation:Optional
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// The fingerprint corresponding to the specified user's private API Key
	// +kubebuilder:validation:Required
	Fingerprint *string `json:"fingerprint" tf:"fingerprint,omitempty"`

	// Optional number of OCPUs for nodes (requires flexible node_shape)
	// +kubebuilder:validation:Optional
	FlexOcpus *float64 `json:"flexOcpus,omitempty" tf:"flex_ocpus,omitempty"`

	// Optional specify the OCID of the KMS Vault master key
	// +kubebuilder:validation:Optional
	KMSKeyIDSecretRef *v1.SecretKeySelector `json:"kmsKeyIdSecretRef,omitempty" tf:"-"`

	// The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
	// +kubebuilder:validation:Required
	KubernetesVersion *string `json:"kubernetesVersion" tf:"kubernetes_version,omitempty"`

	// Optional limit on the total number of nodes in the pool
	// +kubebuilder:validation:Optional
	LimitNodeCount *float64 `json:"limitNodeCount,omitempty" tf:"limit_node_count,omitempty"`

	// The name of the first existing subnet to use for Kubernetes services / LB
	// +kubebuilder:validation:Optional
	LoadBalancerSubnetName1 *string `json:"loadBalancerSubnetName1,omitempty" tf:"load_balancer_subnet_name_1,omitempty"`

	// The (optional) name of a second existing subnet to use for Kubernetes services / LB
	// +kubebuilder:validation:Optional
	LoadBalancerSubnetName2 *string `json:"loadBalancerSubnetName2,omitempty" tf:"load_balancer_subnet_name_2,omitempty"`

	// The OS for the node image
	// +kubebuilder:validation:Required
	NodeImage *string `json:"nodeImage" tf:"node_image,omitempty"`

	// Optional name for DNS domain of node pool subnet
	// +kubebuilder:validation:Optional
	NodePoolDNSDomainName *string `json:"nodePoolDnsDomainName,omitempty" tf:"node_pool_dns_domain_name,omitempty"`

	// Optional name for node pool subnet
	// +kubebuilder:validation:Optional
	NodePoolSubnetName *string `json:"nodePoolSubnetName,omitempty" tf:"node_pool_subnet_name,omitempty"`

	// The contents of the SSH public key file to use for the nodes
	// +kubebuilder:validation:Optional
	NodePublicKeyContents *string `json:"nodePublicKeyContents,omitempty" tf:"node_public_key_contents,omitempty"`

	// The shape of the node (determines number of CPUs and  amount of memory on each node)
	// +kubebuilder:validation:Required
	NodeShape *string `json:"nodeShape" tf:"node_shape,omitempty"`

	// Optional specify the pod CIDR, defaults to 10.244.0.0/16
	// +kubebuilder:validation:Optional
	PodCidr *string `json:"podCidr,omitempty" tf:"pod_cidr,omitempty"`

	// The private API key file contents for the specified user, in PEM format
	// +kubebuilder:validation:Required
	PrivateKeyContentsSecretRef v1.SecretKeySelector `json:"privateKeyContentsSecretRef" tf:"-"`

	// The passphrase of the private key for the OKE cluster
	// +kubebuilder:validation:Optional
	PrivateKeyPassphraseSecretRef *v1.SecretKeySelector `json:"privateKeyPassphraseSecretRef,omitempty" tf:"-"`

	// Number of node subnets (defaults to creating 1 regional subnet)
	// +kubebuilder:validation:Optional
	QuantityOfNodeSubnets *float64 `json:"quantityOfNodeSubnets,omitempty" tf:"quantity_of_node_subnets,omitempty"`

	// Number of worker nodes in each subnet / availability domain
	// +kubebuilder:validation:Optional
	QuantityPerSubnet *float64 `json:"quantityPerSubnet,omitempty" tf:"quantity_per_subnet,omitempty"`

	// The availability domain within the region to host the OKE cluster
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// Optional specify the service CIDR, defaults to 10.96.0.0/16
	// +kubebuilder:validation:Optional
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// Optional name for DNS domain of service subnet
	// +kubebuilder:validation:Optional
	ServiceDNSDomainName *string `json:"serviceDnsDomainName,omitempty" tf:"service_dns_domain_name,omitempty"`

	// Whether to skip deleting VCN
	// +kubebuilder:validation:Optional
	SkipVcnDelete *bool `json:"skipVcnDelete,omitempty" tf:"skip_vcn_delete,omitempty"`

	// The OCID of the tenancy in which to create resources
	// +kubebuilder:validation:Required
	TenancyID *string `json:"tenancyId" tf:"tenancy_id,omitempty"`

	// The OCID of a user who has access to the tenancy/compartment
	// +kubebuilder:validation:Required
	UserOcid *string `json:"userOcid" tf:"user_ocid,omitempty"`

	// The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
	// +kubebuilder:validation:Optional
	VcnCompartmentID *string `json:"vcnCompartmentId,omitempty" tf:"vcn_compartment_id,omitempty"`

	// The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
	// +kubebuilder:validation:Optional
	VcnName *string `json:"vcnName,omitempty" tf:"vcn_name,omitempty"`

	// Additional CIDR from which to allow ingress to worker nodes
	// +kubebuilder:validation:Optional
	WorkerNodeIngressCidr *string `json:"workerNodeIngressCidr,omitempty" tf:"worker_node_ingress_cidr,omitempty"`
}

type OpenstackCloudProviderGlobalObservation struct {
}

type OpenstackCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Required
	AuthURL *string `json:"authUrl" tf:"auth_url,omitempty"`

	// +kubebuilder:validation:Optional
	CAFile *string `json:"caFile,omitempty" tf:"ca_file,omitempty"`

	// +kubebuilder:validation:Optional
	DomainIDSecretRef *v1.SecretKeySelector `json:"domainIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	TenantIDSecretRef *v1.SecretKeySelector `json:"tenantIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`

	// +kubebuilder:validation:Optional
	TrustIDSecretRef *v1.SecretKeySelector `json:"trustIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	UsernameSecretRef v1.SecretKeySelector `json:"usernameSecretRef" tf:"-"`
}

type OpenstackCloudProviderObservation struct {
}

type OpenstackCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	BlockStorage []BlockStorageParameters `json:"blockStorage,omitempty" tf:"block_storage,omitempty"`

	// +kubebuilder:validation:Required
	Global []OpenstackCloudProviderGlobalParameters `json:"global" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Route []RouteParameters `json:"route,omitempty" tf:"route,omitempty"`
}

type PrivateClusterConfigObservation struct {
}

type PrivateClusterConfigParameters struct {

	// Enable GKE cluster private endpoint
	// +kubebuilder:validation:Optional
	EnablePrivateEndpoint *bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`

	// Enable GKE cluster private nodes
	// +kubebuilder:validation:Optional
	EnablePrivateNodes *bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`

	// The GKE cluster private master ip v4 cidr block
	// +kubebuilder:validation:Required
	MasterIPv4CidrBlock *string `json:"masterIpv4CidrBlock" tf:"master_ipv4_cidr_block,omitempty"`
}

type PrivateRegistriesObservation struct {
}

type PrivateRegistriesParameters struct {

	// ECR credential plugin config
	// +kubebuilder:validation:Optional
	EcrCredentialPlugin []EcrCredentialPluginParameters `json:"ecrCredentialPlugin,omitempty" tf:"ecr_credential_plugin,omitempty"`

	// +kubebuilder:validation:Optional
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type Rke2ConfigObservation struct {
}

type Rke2ConfigParameters struct {

	// The RKE2 upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []Rke2ConfigUpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// The RKE2 kubernetes version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type Rke2ConfigUpgradeStrategyObservation struct {
}

type Rke2ConfigUpgradeStrategyParameters struct {

	// Drain server nodes
	// +kubebuilder:validation:Optional
	DrainServerNodes *bool `json:"drainServerNodes,omitempty" tf:"drain_server_nodes,omitempty"`

	// Drain worker nodes
	// +kubebuilder:validation:Optional
	DrainWorkerNodes *bool `json:"drainWorkerNodes,omitempty" tf:"drain_worker_nodes,omitempty"`

	// Server concurrency
	// +kubebuilder:validation:Optional
	ServerConcurrency *float64 `json:"serverConcurrency,omitempty" tf:"server_concurrency,omitempty"`

	// Worker concurrency
	// +kubebuilder:validation:Optional
	WorkerConcurrency *float64 `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`
}

type RkeConfigNetworkObservation struct {
}

type RkeConfigNetworkParameters struct {

	// +kubebuilder:validation:Optional
	CalicoNetworkProvider []CalicoNetworkProviderParameters `json:"calicoNetworkProvider,omitempty" tf:"calico_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CanalNetworkProvider []CanalNetworkProviderParameters `json:"canalNetworkProvider,omitempty" tf:"canal_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	FlannelNetworkProvider []FlannelNetworkProviderParameters `json:"flannelNetworkProvider,omitempty" tf:"flannel_network_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Plugin *string `json:"plugin,omitempty" tf:"plugin,omitempty"`

	// Network add-on tolerations
	// +kubebuilder:validation:Optional
	Tolerations []NetworkTolerationsParameters `json:"tolerations,omitempty" tf:"tolerations,omitempty"`

	// +kubebuilder:validation:Optional
	WeaveNetworkProvider []WeaveNetworkProviderParameters `json:"weaveNetworkProvider,omitempty" tf:"weave_network_provider,omitempty"`
}

type RkeConfigObservation struct {
}

type RkeConfigParameters struct {

	// Optional duration in seconds of addon job.
	// +kubebuilder:validation:Optional
	AddonJobTimeout *float64 `json:"addonJobTimeout,omitempty" tf:"addon_job_timeout,omitempty"`

	// Optional addons descripton to deploy on rke cluster.
	// +kubebuilder:validation:Optional
	Addons *string `json:"addons,omitempty" tf:"addons,omitempty"`

	// Optional addons yaml manisfest to deploy on rke cluster.
	// +kubebuilder:validation:Optional
	AddonsInclude []*string `json:"addonsInclude,omitempty" tf:"addons_include,omitempty"`

	// Kubernetes cluster authentication
	// +kubebuilder:validation:Optional
	Authentication []AuthenticationParameters `json:"authentication,omitempty" tf:"authentication,omitempty"`

	// Kubernetes cluster authorization
	// +kubebuilder:validation:Optional
	Authorization []AuthorizationParameters `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// RKE bastion host
	// +kubebuilder:validation:Optional
	BastionHost []BastionHostParameters `json:"bastionHost,omitempty" tf:"bastion_host,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProvider []CloudProviderParameters `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns,omitempty"`

	// Enable/disable using cri-dockerd
	// +kubebuilder:validation:Optional
	EnableCriDockerd *bool `json:"enableCriDockerd,omitempty" tf:"enable_cri_dockerd,omitempty"`

	// Optional ignore docker version on nodes
	// +kubebuilder:validation:Optional
	IgnoreDockerVersion *bool `json:"ignoreDockerVersion,omitempty" tf:"ignore_docker_version,omitempty"`

	// Kubernetes ingress configuration
	// +kubebuilder:validation:Optional
	Ingress []IngressParameters `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// Optional kubernetes version to deploy
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Kubernetes cluster monitoring
	// +kubebuilder:validation:Optional
	Monitoring []MonitoringParameters `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// Kubernetes cluster networking
	// +kubebuilder:validation:Optional
	Network []RkeConfigNetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// Optional RKE cluster nodes
	// +kubebuilder:validation:Optional
	Nodes []NodesParameters `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// Optional prefix to customize kubernetes path
	// +kubebuilder:validation:Optional
	PrefixPath *string `json:"prefixPath,omitempty" tf:"prefix_path,omitempty"`

	// Optional private registries for docker images
	// +kubebuilder:validation:Optional
	PrivateRegistries []PrivateRegistriesParameters `json:"privateRegistries,omitempty" tf:"private_registries,omitempty"`

	// Optional use ssh agent auth
	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// Optional cluster level SSH certificate path
	// +kubebuilder:validation:Optional
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// Optional cluster level SSH private key path
	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// Kubernetes cluster services
	// +kubebuilder:validation:Optional
	Services []ServicesParameters `json:"services,omitempty" tf:"services,omitempty"`

	// RKE upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []RkeConfigUpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// Optional prefix to customize kubernetes path for windows
	// +kubebuilder:validation:Optional
	WinPrefixPath *string `json:"winPrefixPath,omitempty" tf:"win_prefix_path,omitempty"`
}

type RkeConfigUpgradeStrategyObservation struct {
}

type RkeConfigUpgradeStrategyParameters struct {

	// +kubebuilder:validation:Optional
	Drain *bool `json:"drain,omitempty" tf:"drain,omitempty"`

	// +kubebuilder:validation:Optional
	DrainInput []DrainInputParameters `json:"drainInput,omitempty" tf:"drain_input,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableControlplane *string `json:"maxUnavailableControlplane,omitempty" tf:"max_unavailable_controlplane,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableWorker *string `json:"maxUnavailableWorker,omitempty" tf:"max_unavailable_worker,omitempty"`
}

type RollingUpdateObservation struct {
}

type RollingUpdateParameters struct {

	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type RouteObservation struct {
}

type RouteParameters struct {

	// +kubebuilder:validation:Optional
	RouterID *string `json:"routerId,omitempty" tf:"router_id,omitempty"`
}

type S3BackupConfigObservation struct {
}

type S3BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessKeySecretRef *v1.SecretKeySelector `json:"accessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	BucketName *string `json:"bucketName" tf:"bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCA *string `json:"customCa,omitempty" tf:"custom_ca,omitempty"`

	// +kubebuilder:validation:Required
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SecretKeySecretRef *v1.SecretKeySelector `json:"secretKeySecretRef,omitempty" tf:"-"`
}

type ScanConfigObservation struct {
}

type ScanConfigParameters struct {

	// The cluster cis scan config
	// +kubebuilder:validation:Optional
	CisScanConfig []CisScanConfigParameters `json:"cisScanConfig,omitempty" tf:"cis_scan_config,omitempty"`
}

type ScheduleConfigObservation struct {
}

type ScheduleConfigParameters struct {

	// Crontab schedule
	// +kubebuilder:validation:Required
	CronSchedule *string `json:"cronSchedule" tf:"cron_schedule,omitempty"`

	// Cluster scan retention
	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`
}

type ScheduledClusterScanObservation struct {
}

type ScheduledClusterScanParameters struct {

	// Enable scheduled cluster scan
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Cluster scan config
	// +kubebuilder:validation:Required
	ScanConfig []ScanConfigParameters `json:"scanConfig" tf:"scan_config,omitempty"`

	// Schedule cluster scan config
	// +kubebuilder:validation:Required
	ScheduleConfig []ScheduleConfigParameters `json:"scheduleConfig" tf:"schedule_config,omitempty"`
}

type SchedulerObservation struct {
}

type SchedulerParameters struct {

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type SecretsEncryptionConfigObservation struct {
}

type SecretsEncryptionConfigParameters struct {

	// +kubebuilder:validation:Optional
	CustomConfig *string `json:"customConfig,omitempty" tf:"custom_config,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServiceOverrideObservation struct {
}

type ServiceOverrideParameters struct {

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// +kubebuilder:validation:Optional
	SigningMethod *string `json:"signingMethod,omitempty" tf:"signing_method,omitempty"`

	// +kubebuilder:validation:Optional
	SigningName *string `json:"signingName,omitempty" tf:"signing_name,omitempty"`

	// +kubebuilder:validation:Optional
	SigningRegion *string `json:"signingRegion,omitempty" tf:"signing_region,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type ServicesObservation struct {
}

type ServicesParameters struct {

	// +kubebuilder:validation:Optional
	Etcd []EtcdParameters `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// +kubebuilder:validation:Optional
	KubeAPI []KubeAPIParameters `json:"kubeApi,omitempty" tf:"kube_api,omitempty"`

	// +kubebuilder:validation:Optional
	KubeController []KubeControllerParameters `json:"kubeController,omitempty" tf:"kube_controller,omitempty"`

	// +kubebuilder:validation:Optional
	Kubelet []KubeletParameters `json:"kubelet,omitempty" tf:"kubelet,omitempty"`

	// +kubebuilder:validation:Optional
	Kubeproxy []KubeproxyParameters `json:"kubeproxy,omitempty" tf:"kubeproxy,omitempty"`

	// +kubebuilder:validation:Optional
	Scheduler []SchedulerParameters `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type TaintsObservation struct {
}

type TaintsParameters struct {

	// +kubebuilder:validation:Required
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TolerationsObservation struct {
}

type TolerationsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type UpdateStrategyObservation struct {
}

type UpdateStrategyParameters struct {

	// Rolling update for update strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []RollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`
}

type UpdateStrategyRollingUpdateObservation struct {
}

type UpdateStrategyRollingUpdateParameters struct {

	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type UpgradeStrategyObservation struct {
}

type UpgradeStrategyParameters struct {

	// Drain server nodes
	// +kubebuilder:validation:Optional
	DrainServerNodes *bool `json:"drainServerNodes,omitempty" tf:"drain_server_nodes,omitempty"`

	// Drain worker nodes
	// +kubebuilder:validation:Optional
	DrainWorkerNodes *bool `json:"drainWorkerNodes,omitempty" tf:"drain_worker_nodes,omitempty"`

	// Server concurrency
	// +kubebuilder:validation:Optional
	ServerConcurrency *float64 `json:"serverConcurrency,omitempty" tf:"server_concurrency,omitempty"`

	// Worker concurrency
	// +kubebuilder:validation:Optional
	WorkerConcurrency *float64 `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`
}

type VirtualCenterObservation struct {
}

type VirtualCenterParameters struct {

	// +kubebuilder:validation:Required
	Datacenters *string `json:"datacenters" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type VsphereCloudProviderGlobalObservation struct {
}

type VsphereCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Optional
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Optional
	InsecureFlag *bool `json:"insecureFlag,omitempty" tf:"insecure_flag,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type VsphereCloudProviderObservation struct {
}

type VsphereCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Global []VsphereCloudProviderGlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Required
	VirtualCenter []VirtualCenterParameters `json:"virtualCenter" tf:"virtual_center,omitempty"`

	// +kubebuilder:validation:Required
	Workspace []WorkspaceParameters `json:"workspace" tf:"workspace,omitempty"`
}

type WeaveNetworkProviderObservation struct {
}

type WeaveNetworkProviderParameters struct {

	// +kubebuilder:validation:Required
	Password *string `json:"password" tf:"password,omitempty"`
}

type WorkspaceObservation struct {
}

type WorkspaceParameters struct {

	// +kubebuilder:validation:Required
	Datacenter *string `json:"datacenter" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDatastore *string `json:"defaultDatastore,omitempty" tf:"default_datastore,omitempty"`

	// +kubebuilder:validation:Required
	Folder *string `json:"folder" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcepoolPath *string `json:"resourcepoolPath,omitempty" tf:"resourcepool_path,omitempty"`

	// +kubebuilder:validation:Required
	Server *string `json:"server" tf:"server,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
