/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActiveDirectoryObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ActiveDirectoryParameters struct {

	// +kubebuilder:validation:Optional
	AccessMode *string `json:"accessMode,omitempty" tf:"access_mode,omitempty"`

	// +kubebuilder:validation:Optional
	AllowedPrincipalIds []*string `json:"allowedPrincipalIds,omitempty" tf:"allowed_principal_ids,omitempty"`

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateSecretRef *v1.SecretKeySelector `json:"certificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty" tf:"connection_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultLoginDomain *string `json:"defaultLoginDomain,omitempty" tf:"default_login_domain,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	GroupDnAttribute *string `json:"groupDnAttribute,omitempty" tf:"group_dn_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupMemberMappingAttribute *string `json:"groupMemberMappingAttribute,omitempty" tf:"group_member_mapping_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupMemberUserAttribute *string `json:"groupMemberUserAttribute,omitempty" tf:"group_member_user_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupNameAttribute *string `json:"groupNameAttribute,omitempty" tf:"group_name_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupObjectClass *string `json:"groupObjectClass,omitempty" tf:"group_object_class,omitempty"`

	// +kubebuilder:validation:Optional
	GroupSearchAttribute *string `json:"groupSearchAttribute,omitempty" tf:"group_search_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	GroupSearchBase *string `json:"groupSearchBase,omitempty" tf:"group_search_base,omitempty"`

	// +kubebuilder:validation:Optional
	GroupSearchFilter *string `json:"groupSearchFilter,omitempty" tf:"group_search_filter,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	NestedGroupMembershipEnabled *bool `json:"nestedGroupMembershipEnabled,omitempty" tf:"nested_group_membership_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Servers []*string `json:"servers" tf:"servers,omitempty"`

	// +kubebuilder:validation:Required
	ServiceAccountPasswordSecretRef v1.SecretKeySelector `json:"serviceAccountPasswordSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	ServiceAccountUsernameSecretRef v1.SecretKeySelector `json:"serviceAccountUsernameSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	StartTLS *bool `json:"startTls,omitempty" tf:"start_tls,omitempty"`

	// +kubebuilder:validation:Optional
	TLS *bool `json:"tls,omitempty" tf:"tls,omitempty"`

	// +kubebuilder:validation:Required
	TestPasswordSecretRef v1.SecretKeySelector `json:"testPasswordSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	TestUsername *string `json:"testUsername" tf:"test_username,omitempty"`

	// +kubebuilder:validation:Optional
	UserDisabledBitMask *float64 `json:"userDisabledBitMask,omitempty" tf:"user_disabled_bit_mask,omitempty"`

	// +kubebuilder:validation:Optional
	UserEnabledAttribute *string `json:"userEnabledAttribute,omitempty" tf:"user_enabled_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	UserLoginAttribute *string `json:"userLoginAttribute,omitempty" tf:"user_login_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	UserNameAttribute *string `json:"userNameAttribute,omitempty" tf:"user_name_attribute,omitempty"`

	// +kubebuilder:validation:Optional
	UserObjectClass *string `json:"userObjectClass,omitempty" tf:"user_object_class,omitempty"`

	// +kubebuilder:validation:Optional
	UserSearchAttribute *string `json:"userSearchAttribute,omitempty" tf:"user_search_attribute,omitempty"`

	// +kubebuilder:validation:Required
	UserSearchBase *string `json:"userSearchBase" tf:"user_search_base,omitempty"`

	// +kubebuilder:validation:Optional
	UserSearchFilter *string `json:"userSearchFilter,omitempty" tf:"user_search_filter,omitempty"`
}

// ActiveDirectorySpec defines the desired state of ActiveDirectory
type ActiveDirectorySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ActiveDirectoryParameters `json:"forProvider"`
}

// ActiveDirectoryStatus defines the observed state of ActiveDirectory.
type ActiveDirectoryStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ActiveDirectoryObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ActiveDirectory is the Schema for the ActiveDirectorys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type ActiveDirectory struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ActiveDirectorySpec   `json:"spec"`
	Status            ActiveDirectoryStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ActiveDirectoryList contains a list of ActiveDirectorys
type ActiveDirectoryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ActiveDirectory `json:"items"`
}

// Repository type metadata.
var (
	ActiveDirectory_Kind             = "ActiveDirectory"
	ActiveDirectory_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ActiveDirectory_Kind}.String()
	ActiveDirectory_KindAPIVersion   = ActiveDirectory_Kind + "." + CRDGroupVersion.String()
	ActiveDirectory_GroupVersionKind = CRDGroupVersion.WithKind(ActiveDirectory_Kind)
)

func init() {
	SchemeBuilder.Register(&ActiveDirectory{}, &ActiveDirectoryList{})
}
