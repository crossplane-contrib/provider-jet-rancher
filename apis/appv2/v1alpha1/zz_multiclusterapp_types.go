/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AnswersObservation struct {
}

type AnswersParameters struct {

	// Cluster ID for answer
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Project ID for answer
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Key/values for answer
	// +kubebuilder:validation:Optional
	Values map[string]*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MembersObservation struct {
}

type MembersParameters struct {

	// Member access type: member, owner, read-only
	// +kubebuilder:validation:Optional
	AccessType *string `json:"accessType,omitempty" tf:"access_type,omitempty"`

	// Member group principal id
	// +kubebuilder:validation:Optional
	GroupPrincipalID *string `json:"groupPrincipalId,omitempty" tf:"group_principal_id,omitempty"`

	// Member user principal id
	// +kubebuilder:validation:Optional
	UserPrincipalID *string `json:"userPrincipalId,omitempty" tf:"user_principal_id,omitempty"`
}

type MultiClusterAppObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	TemplateVersionID *string `json:"templateVersionId,omitempty" tf:"template_version_id,omitempty"`
}

type MultiClusterAppParameters struct {

	// Annotations of the resource
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Multi cluster app answers
	// +kubebuilder:validation:Optional
	Answers []AnswersParameters `json:"answers,omitempty" tf:"answers,omitempty"`

	// Multi cluster app catalog name
	// +kubebuilder:validation:Required
	CatalogName *string `json:"catalogName" tf:"catalog_name,omitempty"`

	// Labels of the resource
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Multi cluster app members
	// +kubebuilder:validation:Optional
	Members []MembersParameters `json:"members,omitempty" tf:"members,omitempty"`

	// Multi cluster app revision history limit
	// +kubebuilder:validation:Optional
	RevisionHistoryLimit *float64 `json:"revisionHistoryLimit,omitempty" tf:"revision_history_limit,omitempty"`

	// Multi cluster app revision name
	// +kubebuilder:validation:Optional
	RevisionID *string `json:"revisionId,omitempty" tf:"revision_id,omitempty"`

	// Multi cluster app roles
	// +kubebuilder:validation:Required
	Roles []*string `json:"roles" tf:"roles,omitempty"`

	// Multi cluster app targets
	// +kubebuilder:validation:Required
	Targets []TargetsParameters `json:"targets" tf:"targets,omitempty"`

	// Multi cluster app template name
	// +kubebuilder:validation:Required
	TemplateName *string `json:"templateName" tf:"template_name,omitempty"`

	// Multi cluster app template version
	// +kubebuilder:validation:Optional
	TemplateVersion *string `json:"templateVersion,omitempty" tf:"template_version,omitempty"`

	// Multi cluster app upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []UpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`

	// Wait until multi cluster app is active
	// +kubebuilder:validation:Optional
	Wait *bool `json:"wait,omitempty" tf:"wait,omitempty"`
}

type RollingUpdateObservation struct {
}

type RollingUpdateParameters struct {

	// Rolling update batch size
	// +kubebuilder:validation:Optional
	BatchSize *float64 `json:"batchSize,omitempty" tf:"batch_size,omitempty"`

	// Rolling update interval
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`
}

type TargetsObservation struct {
	AppID *string `json:"appId,omitempty" tf:"app_id,omitempty"`

	HealthState *string `json:"healthState,omitempty" tf:"health_state,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type TargetsParameters struct {

	// Project ID for target
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`
}

type UpgradeStrategyObservation struct {
}

type UpgradeStrategyParameters struct {

	// Rolling update for upgrade strategy
	// +kubebuilder:validation:Optional
	RollingUpdate []RollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`
}

// MultiClusterAppSpec defines the desired state of MultiClusterApp
type MultiClusterAppSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MultiClusterAppParameters `json:"forProvider"`
}

// MultiClusterAppStatus defines the observed state of MultiClusterApp.
type MultiClusterAppStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MultiClusterAppObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MultiClusterApp is the Schema for the MultiClusterApps API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancherjet}
type MultiClusterApp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MultiClusterAppSpec   `json:"spec"`
	Status            MultiClusterAppStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MultiClusterAppList contains a list of MultiClusterApps
type MultiClusterAppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MultiClusterApp `json:"items"`
}

// Repository type metadata.
var (
	MultiClusterApp_Kind             = "MultiClusterApp"
	MultiClusterApp_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MultiClusterApp_Kind}.String()
	MultiClusterApp_KindAPIVersion   = MultiClusterApp_Kind + "." + CRDGroupVersion.String()
	MultiClusterApp_GroupVersionKind = CRDGroupVersion.WithKind(MultiClusterApp_Kind)
)

func init() {
	SchemeBuilder.Register(&MultiClusterApp{}, &MultiClusterAppList{})
}
